<?php
/**
 * @file
 * Code for Elections.
 */

/**
 * Implements hook_permission().
 */
function election_permission() {
  return array(
    'can vote on elections'=> array(
      'title' => t('can vote on elections'),
      'description' => t('Vote on elections.'),
    ),
    'administrate elections'=> array(
      'title' => t('administrate elections'),
      'description' => t('Administrate elections.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function election_menu() {
  $items['admin/vaxia/election'] = array(
    'title' => 'Election settings',
    'description' => 'Elections for administration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_election_admin_settings'),
    'access arguments' => array('administrate elections'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_rules_event_info().
 */
function election_rules_event_info() {
  $items = array(
    'open_election' => array(
      'label' => t('Election open'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
      ),
    ),
    'close_election' => array(
      'label' => t('Election close'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'ties' => array(
            'type' => 'list<text>',
            'label' => t('Ties'),
        ),
      ),
    ),
    'open_runoff_election' => array(
      'label' => t('Election runoff'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election runoff'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'ties' => array(
            'type' => 'list<text>',
            'label' => t('Ties'),
        ),
      ),
    ),
    'cancelled_election' => array(
      'label' => t('Election cancelled'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election cancelled'),
        ),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_node_delete().
 */
function election_node_delete($node) {
  // Delete an election associated with a proposal if we delete the node.
  if ($node->type == 'proposal') {
    _election_delete_election_by_nid($node->nid);
  }
}

/**
 * Implements hook_node_update().
 */
function election_node_update($node) {
  // Check a proposal for an election value.
  if ($node->type == 'proposal') {
    _election_election_check_close($node);
  }
}

/**
 * Implements hook_cron().
 */
function election_cron() {
  $last_run = variable_get('election_cron', 0);
  $yesterday = strtotime('-1 day');
  if ($last_run < $yesterday) {
    $today = date('m/d/Y');
    $today = strtotime($today . ' 00:00:01'); // We always want to plan to run just after midnight.
    variable_set('election_cron', $today);
    _election_cron_election();
  }
}

/**
 * Implements hook_cronapi().
 */
function election_cronapi($op, $job = NULL) {
  $items['_election_cron_election'] = array(
  	'description' => 'Election: Check election day',
  	'rule' => '1 0 * * *', // Once every day at 12:01 AM.
  );
  return $items;
}

/**
 * Cron handler for elections.
 */
function _election_cron_election() {
  $election_day = _election_check_election_day();
  if ($election_day) {
    // This is an official election! Time to get things sorted out.
    // First remove current heads from positions, put admin in for anon mailer.
    $role = variable_get('election_role', '');
    db_query('DELETE FROM {users_roles} WHERE rid = :rid',
      array(':uid' => $winner->uid, ':rid' => $role));
    $data = array('uid' => 1, 'rid' => $role);
    drupal_write_record('users_roles', $data);
    // And start the election.
    _election_trigger_election();
  }
}

/**
 * Helper function. Check if today is election day.
 */
function _election_check_election_day() {
  // Grab the info about the last election and when / how to run it.
  $last_held = variable_get('election_day', '5/1/2013');
  $rate = variable_get('election_rate', '1 year');
  // Based on the last election, get the next election in a standard format.
  $last_election = strtotime($last_held);
  $next_election = date('m/d/Y', strtotime($rate, $last_election));
  // Calculate today, see if it's the same values in a standard format.
  $today = date('m/d/Y', strtotime('now'));
  // Do they match? Mark today in the variables.
  if ($today == $next_election) {
    variable_set('election_day', date('m/d/Y'));
    return TRUE;
  }
  return FALSE;
}

/**
 * Menu callback, admin form.
 */
function _election_admin_settings($form, &$form_state) {
  $form['election_day'] = array(
    '#title' => t('Last election day'),
    '#description' => t('The last-held election day for calculating further elections.'),
    '#type' => 'textfield',
    '#disabled' => TRUE,
    '#default_value' => variable_get('election_day', '5/1/2013'),
    '#value' => variable_get('election_day', '5/1/2013'),
  );
  $form['election_rate'] = array(
    '#title' => t('Election rate'),
    '#description' => t('How often to hold elections. Use timeframe formats strtotime will recognize.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_rate', '1 year'),
  );
  $form['election_term_limits'] = array(
    '#title' => t('Term limits'),
    '#description' => t('Use term limits when calculating eligable users for positions.'),
    '#type' => 'checkbox',
    '#default_value' => variable_get('election_term_limits', TRUE),
  );
  $form['election_term_limit_limits'] = array(
    '#title' => t('Term limit'),
    '#description' => t('How many consecutive (not lifetime) terms can a user serve in the same position.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_term_limit_limits', 2),
  );
  $form['election_run_roles'] = array(
    '#title' => t('Election run role'),
    '#description' => t('These roles are allowed to run.'),
    '#type' => 'select',
    '#multiple' => TRUE,
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_run_roles', array()),
  );
  $form['election_role'] = array(
    '#title' => t('Elected role'),
    '#description' => t('This role is considered the elected role. Election winners automatically recieve this role.'),
    '#type' => 'select',
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_role', ''),
  );
  $vid = variable_get('forum_nav_vocabulary', 0);
  $options = array();
  if ($terms = taxonomy_get_tree($vid)) {
    foreach ($terms as $term) {
      $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
    }
  }
  $form['election_default_forum'] = array(
    '#title' => t('Election forum'),
    '#description' => t('The default forum to post the election proposal in.'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => variable_get('election_default_forum', ''),
  );
  $intro_text = t('Each year we have an election for key positions on our site. ' .
    'This is so that we can always be sure that the current leadership is connected to ' .
    'and trusted by our players.');
  $form['election_election_intro'] = array(
    '#title' => t('Election intro'),
    '#description' => t('Election introduction text.'),
    '#type' => 'textarea',
    '#default_value' => variable_get('election_election_intro', $intro_text),
  );
  $positions = _election_get_positions();
  $available = implode("\n", $positions);
  if (empty($positions)) {
    $available = implode("\n", array('Setting Lead', 'System Lead', 'Social Lead') );
  }
  $form['election_positions'] = array(
    '#title' => t('Available positions'),
    '#description' => t('List postitions available on the site, one per row.'),
    '#type' => 'textarea',
    '#default_value' => $available,
  );
  $form['election_open_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Hold an election off-cycle'),
    '#submit' => array('_election_open_submit'),
  );
  $form['election_close_election'] = array(
    '#type' => 'submit',
    '#value' => t('Close open elections'),
    '#submit' => array('_election_close_submit'),
  );
  $form['#submit'][] = '_election_positions_submit';
  return system_settings_form($form);
}

/**
 * Submit callback, close open elections.
 */
function _election_close_submit($form, &$form_state) {
  // And get the correct timeframe assuming a start time of 2 weeks ago.
  $proposals = db_query('SELECT n.nid FROM {node} n ' .
    'LEFT JOIN webform w ON n.nid = w.nid ' .
    'WHERE n.type = \'proposal\' ' .
    'AND n.status = 1 ' .
    'AND w.status = 1 ');
  // Trigger event.
  foreach ($proposals as $proposal) {
    $election = _election_get_election_by_nid($proposal->nid);
    if ($election) {
      if (function_exists('rules_invoke_event')) {
        $node = node_load($proposal->nid);
        // Clear out the disallowed roles option for this proposal
        $disallowed = variable_get('proposal_disallowed_roles', array());
        if (isset($disallowed[ $node->nid ])) {
          unset($disallowed[ $node->nid ]);
        }
        variable_set('proposal_disallowed_roles', $disallowed);
        // Call the rules.
        rules_invoke_event('close_proposal', $node);
      }
    }
  }
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _election_open_submit($form, &$form_state) {
  // This is an official election! Time to get things sorted out.
  // First remove current heads from positions, put admin in for anon mailer.
  $elected_role = variable_get('election_role', '');
  // Remove current people from position.
  // This ONLY happens during election triggers like form or cron.
  // It does NOT happen on runoff elections.
  db_query('DELETE FROM {users_roles} WHERE rid = :rid', array(':rid' => $elected_role));
  // Set user one as the temporary position holder.
  $data = array('uid' => 1, 'rid' => $elected_role);
  drupal_write_record('users_roles', $data);
  // And start the election.
  variable_set('election_day', date('m/d/Y'));
  _election_trigger_election();
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _election_positions_submit($form, &$form_state) {
  // Grab the old positions.
  // TODO: For now, leave it to the admin to delete the old ones.
  // Grab the new positions from the settings.
  $positions = isset($form_state['values']['election_positions']) ?
    $form_state['values']['election_positions'] : '';
  $positions = explode("\n", $positions);
  $available = array();
  foreach ($positions as $index => $position) {
    $position = trim($position); // Trim.
    if (!empty($position)) {
      $available[] = $position;
    }
  }
  // Make sure to set the variable early so the position fields can use it.
  variable_set('election_positions', implode("\n", $available));
  // And create fields.
  if (!empty($available)) {
    create_election_position_fields();
  }
}

/**
 * Create an election set with all relevant data.
 * Title is optional, can be set to override default.
 * Postions optiona, can be set to override defaults in for example runoffs.
 * Election is the election object for tracking the cycle - for runoffs.
 */
function _election_trigger_election($title = '', $positions = array(), $election = array()) {
  // Make sure we have the right positions in place.
  create_election_position_fields();
  // Create the node.
  $title = !empty($title) ? $title : t('Site Election');
  $node->title = date('m/d/Y') . ' ' . $title;
  $node->type = 'proposal';
  $node->uid = 1;
  $node->language = 'und';
  // node_save($node);
  // Post to the correct forum.
  $tid = variable_get('election_default_forum', '');
  $node->taxonomy_forums[ $node->language ][0]['tid'] = !empty($tid) ? $tid : '';
  node_save($node);
  $node = node_load($node->nid);
  // Check that the node was properly created.
  if (!empty($node)) {
    // Ok, set up the webform elements for this election.
    _election_setup_election_proposal($node, $positions, $election);
  }
  // If we have rules, trigger it.
  if (function_exists('rules_invoke_event')) {
    rules_invoke_event('open_election', $node);
  }
}

/**
 * Helper function. Create an election webform with the right settings.
 */
function _election_setup_election_proposal($new_election, $positions = array(), $election = array()) {

  // Figure out the positions.
  // If we were passed positions for this election, use those. (Probably a runoff.)
  if (empty($positions)) {
    // Otherwise load the list from the stored variable.
    $positions = _election_get_positions();
  }

  // Trim up for possible bad input.
  foreach ($positions as $index => $position) {
    $position = trim($position);
    if (!empty($position)) {
      $positions[$index] = $position;
    }
  }

  // Set the webform body and basic configuration.
  $output = '';
  $output .= '<h3><b>' . t('Election') . '</b></h3>';
  $output .= '<p>' . variable_get('election_election_intro', '') . '</p>';
  $output .= '<p>' . t('Available positions are:') . '</p>';
  $output .= theme('item_list', array('items' => $positions));
  $output .= '<p>Please take a moment to review the candidates for this ' .
    'year and select those you feel to be the best choices for the available positions.</p>';
  $new_election->body[$new_election->language][0]['value'] = $output;
  // Set up the webform defaults if node hasn't yet.
  if (!isset($new_election->webform)) {
    $new_election->webform = webform_node_defaults();
  }
  $new_election->webform['confirmation'] = t('Thank you for participating!');
  $new_election->webform['confirmation_format'] = 'plain_text';
  $new_election->webform['submit_limit'] = 1;
  // Set approving roles for users based on all roles with 'can vote on elections' permission.
  $election_voting_roles = user_roles(FALSE, 'can vote on elections');
  $record = db_query('DELETE FROM {webform_roles} WHERE nid = :nid', array(':nid' => $new_election->nid));
  $roles = array();
  foreach ($election_voting_roles as $rid => $role) {
    if ($role) {
      $roles[] = $rid;
    }
  }
  // Set the default users.
  $new_election->webform['roles'] = $roles;
  _proposal_webform_set_users($roles, array(), $new_election->nid);
  // Set the status to ON on new elections.
  $new_election->webform['status'] = TRUE;
  node_save($new_election);

  // And now the fun part: set the components for the form.
  _election_setup_election_proposal_components($new_election, $positions);

  // And now we mark this proposal as having been created in our site as an election object.
  $data = array(
    'nid' => $new_election->nid,
    'positions' => $positions,
    'closed' => -1,
    'winners' => array(),
  );
  $data = array_merge( (array) $election, $data); // Merge any existing election info.
  if (isset($data['eid'])) {
    // It's a runoff election, new node, but same cycle, same positions.
    unset($data['eid']);
  }
  $data = _election_update_election($data);

  // And set a message to our user.
  drupal_set_message(t('A new election has been created at !link.',
    array('!link' => l($new_election->title, 'node/' . $new_election->nid))));
}

/**
 * Helper function. Create the components for an election form.
 */
function _election_setup_election_proposal_components($new_election, $positions) {
  // Include the webform module that allows components to be created.
  module_load_include('inc', 'webform', 'includes/webform.components');
  // Create the webform fields for possible elected.
  $weight = 0;
  $positions_ready = FALSE;
  foreach ($positions as $position) {
    // Get the key to use.
    $field_key_name = get_field_key_name($position);
    if ($field_key_name) {
      // Gather the user info.
      $run_roles = variable_get('election_run_roles', array());
      $run_roles = array_values($run_roles);
      $elected_role = variable_get('election_role', '');
      $candidates = db_query('SELECT DISTINCT u.name, u.uid FROM {users} u ' . 
        'LEFT JOIN {users_roles} ur ON u.uid = ur.uid ' .
        'LEFT JOIN {field_data_field_staff_' . $field_key_name . '} f ON u.uid = f.entity_id ' .
        'WHERE ur.rid IN (:run_roles) ' . // They're in the role for running.
        'AND u.uid NOT IN (SELECT ur2.uid FROM users_roles ur2 WHERE ur2.rid IN (:elected_role) ) ' . // Can't hold more than one position.
        'AND f.field_staff_' . $field_key_name . '_value = 1 ' . // And they haven't opted out.
        'ORDER BY u.name', // Alphabetical order.
        array(':run_roles' => $run_roles, ':elected_role' => $elected_role));

      // Check the user for eligabilty and term limits.
      $eligable_candidates = '';
      $term_limits = variable_get('election_term_limits', TRUE);
      $term_limits_limit = variable_get('election_term_limit_limits', 2);
      foreach ($candidates as $candidate) {
        $eligable = TRUE;
        if ($term_limits) {
          // Check for this position key if the user has the ok or if they need to lay off for a bit.
          $eligable = !_election_is_at_term_limit( $candidate->uid, $term_limits_limit, $field_key_name);
        }
        // If we're still ok, add em.
        if($eligable) {
          $eligable_candidates .= $candidate->name . '|' . $candidate->name . "\n";
        }
      }

      // Create the component for the position IF we have any eligable candidates.
      if (!empty($eligable_candidates)) {
        $component = array();
        $component['nid'] = $new_election->nid;
        $component['pid'] = 0;
        $component['form_key'] = $field_key_name; // Use the position fieldname as the key.
        $component['name'] = $position;
        $component['type'] = 'select';
        $component['mandatory'] = 1;
        $component['extra'] = array(
          'description' => '',
          'items' => $eligable_candidates,
          'multiple' => '0',
          'aslist' => '1',
        );
        $component['weight'] = $weight;
        $weight++;
        webform_component_insert($component);
        $positions_ready = TRUE;
      }
      else {
        $component = array();
        $component['nid'] = $new_election->nid;
        $component['pid'] = 0;
        $component['form_key'] = $field_key_name . '_nc'; // Use the position fieldname as the key.
        $component['name'] = $position;
        $component['type'] = 'markup';
        $component['mandatory'] = 0;
        $component['value'] = t('There are no eligable candidates for ' . $position . '.');
        $component['extra'] = array(
          'format' => 'filtered_html',
          'private' => 0,
        );
        $component['weight'] = $weight;
        $weight++;
        webform_component_insert($component);
        watchdog('election', 'This election has no candidates for ' . $position . '.');
        drupal_set_message(t('This election has no candidates for ' . $position . '.'));
      }
    } // Done with the if for each position key name.
  } // Done with loop for positions.

  // If we didn't find anyone for any of these positions we really don't
  // have enough people for an election. This is an EMERGENCY situation
  // that we should mark as such - also we close the election right now
  // to avoid triggering any future looping until we're ready to elect.
  if (!$positions_ready) {
    // Reload the election before saving any changes to make sure we don't
    // zap any components that were placed on it since the last load.
    $new_election = node_load($new_election->nid);
    $new_election->title .= ' ' . t('(Cancelled)');
    $new_election->status = 0; // TMP hiden from view.
    $new_election->webform['status'] = FALSE;
    watchdog('election', 'This election has no candidates for ANY position. It has been automatically closed without runoff.');
    drupal_set_message(t('This election has no candidates for ANY position. It has been automatically closed without runoff.'), 'error');
    node_save($new_election);
    // And set rule to trigger in case of a cancelled election.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('cancelled_election', $new_election);
    }
  }
  else {
    // Copy from proposal.module - include the comment field.
    $component = array();
    $component['nid'] = $new_election->nid;
    $component['pid'] = 0;
    $component['form_key'] = 'additional_comments';
    $component['name'] = t('Additional Comments');
    $component['type'] = 'textarea';
    $component['mandatory'] = 0;
    $component['extra'] = array();
    $component['weight'] = 1000;
    webform_component_insert($component);
  }
}

/**
 * Handle when we close an election. Called on proposal close.
 */
function _election_election_check_close($node) {
  $election = _election_get_election_by_nid($node->nid);
  // Check if we are closed. If we aren't an election this returns nothing.
  if ($election && $election->closed == -1 && $node->webform['status'] == FALSE) {

    // Close the election.
    $election->closed = strtotime('now');
    $election->winners = array();
    $elected_role = variable_get('election_role', '');
    // And save this election as done.
    _election_update_election($election);
    // Read the results into a readable array.
    $results = _election_get_results($node);

    // Gather winners and set them up.
    $winners = _election_get_winners($node, $results); // Return as assoc array, array('position' => 'uid');
	if (!empty($winners)) {
      // User one is no longer required to operated as a temporary position.
      db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
        array(':uid' => 1, ':rid' => $elected_role));
      // Now process the winners, marking them for terms etc as needed.
      foreach ($winners as $position => $winner) {
        // Add the winner to the heads role.
        db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
          array(':uid' => $winner, ':rid' => $elected_role));
        $data = array('uid' => $winner, 'rid' => $elected_role);
        drupal_write_record('users_roles', $data);
        // And for each winner, mark that they've been assigned for this cycle to this position.
        $this_winner = _election_mark_winner(array(
          'uid' => $winner,
          'cycle' => $election->cycle,
          'position' => $position,
        ));
      }
      // Add to the election information recorded so far.
      $election->winners = $winners;
    }

    // Gather ties and set up a runoff.
    $ties = _election_get_ties($node, $results, $winners); // Return as assoc array, array('position' => 'uid');
	if (!empty($ties)) {
      // We need to run a tie breaker election with JUST these postions.
      // So we open ANOTHER election, not the same one.
      // Technically this could go on forever.
      _election_trigger_election(t('Site Run-off Election'), $ties, $election);
      // If we have rules, trigger it.
      if (function_exists('rules_invoke_event')) {
        rules_invoke_event('open_runoff_election', $node, array_values($winners), $ties);
      }
    }

    // And save this election as done.
    _election_update_election($election);
    // If we have rules, trigger it.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('close_election', $node, array_values($winners), $ties);
    }
  }
}

/**
 * RECURSIVE function, determine who the winner is.
 */
function _election_get_winners_by_position($results) {
  // Figure out who the exact winners are.
  // Naive voting - it's whoever has the most votes for the position.
  // Now it's possible for a candidate to get elected to TWO or more positions.
  // In which case we need to boot him for which-ever one was least voted for.
  // And and put the second in place.
  $winners = array();
  $sub_results = array();
  foreach ($results as $position => $candidates) {
    // Numerically winning candidate.
    $votes_got = max($candidates);
    $candidates_with_max = array_keys($candidates, $votes_got);
    // If we have more than one winner, it's a tie. But if only one, then we have a front runner.
    if ($votes_got > 0 && count($candidates_with_max) == 1) {
      $candidates_with_max = $candidates_with_max[0];
      // Possible winner! We have to make sure he didn't win anything else though first.
      if (empty($positions[$candidates_with_max])) {
        // Hasn't won anything so far, so put winner in this one.
        $winners[$position] = $candidates_with_max;
        $positions[$candidates_with_max] = $votes_got;          
      }
      else {
        // Ok - he has won something already. So is this the one to stay with or the other?
        if ($votes_got <= $positions[$candidates_with_max]) {
          // If this position is less than or equal to the previous one found, set this position to re-do.
          // Remove this candidate from this set by setting votes to zero.
          $results[$position][$candidates_with_max] = 0;
          // And add the position to the dupes for redo.
          $sub_results[$position] = $results[$position];
        }
        else {
          // If this position is greater than or less than the previous one, set the other to re-do.
          $old_position = array_keys($winners, $candidates_with_max);
          unset($winners[$old_position]);
          // Remove this candidate from that set by setting votes to zero.
          $results[$old_position][$candidates_with_max] = 0;
          // And add the position to the dupes for redo.
          $sub_results[$old_position] = $results[$old_position];
          // And add the new position for this winner instead.
          $winners[$position] = $candidates_with_max;
          $positions[$candidates_with_max] = $votes_got;
        }
      }
    } // End if, no clear winner to check.
  } // End check each position.

  // RECURSIVE HERE.
  // Check everything that was a dupe for sub-winners.
  // This should return a set of winners ignoring the dupe winners from above.
  // For all positions not already won - so all we have to do is merge arrays.
  if (!empty($sub_results)) {
    $sub_winners = _election_get_winners_by_position($sub_results);
    $winners = array_merge($winners, $sub_winners);
  }
  return $winners;
}

/**
 * Helper function, given an election node figure out who the winners are.
 */
function _election_get_winners($node, $results) {
  $winners = _election_get_winners_by_position($results);
  // NOTE: THIS IS A SIMPLE ELECTION MECHANIC.
  // Aka, he with the most votes wins.
  // This does NOT require minimum # of voters to participate. Or min % of the vote
  // for the winner to be marked with the lead position and ready to go.
  // This is not nessecarily ideal! So we should ABSOLUTELY allow for hook overrides here.
  // So that more than one voting winner may be determined.
  drupal_alter('election_winners', $winners, $results, $node);
  // To modify the election results, call hook_election_winners_alter(&$winners, $results, $node);
  return $winners;
}

/**
 * Helper function, given an election node figure out who the winners are.
 */
function _election_get_ties($node, $results, $winners) {
  // Map components to head positions.
  $ties = array();
  foreach ($results as $position => $candidates) {
    // If the position doesn't have a clear winner, it's a tie.
    if (!in_array($position, array_keys($winners))) {
      $hn_position = get_field_human_name($position);
      if ($hn_position) {
        $ties[] = $hn_position; // ALL candidates go up for the re-election vote, no need to set values here.
        watchdog('election', 'This election has a TIE for ' . $hn_position . '. Another follow-up should be run.');
        drupal_set_message(t('This election has a TIE for ' . $hn_position . '. Another follow-up should be run.'));
      }
    }
  }
  return $ties;
}

/**
 * Helper function, summarize election results in a readable array.
 */
function _election_get_results($node) {
  // Include the webform file we need.
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  // Local cache of looked up users by name.
  $users = array();
  // Get submission results and put into a format for review.
  $submissions = webform_get_submissions($node->nid);
  $results = array();
  if (!empty($submissions)) {
    foreach ($submissions as $sid => $submission) {
      // Process each submission.
      foreach ($submission->data as $cid => $submission_answer) {
        // Process each position for each compontent.
        $component = $node->webform['components'][$cid];
        if ($component['form_key'] != 'additional_comments') {
          // Get the position key name.
          $position = $component['form_key'];
          // Get the user. NOTE this is the user's name, not uid.
          $voted_for = $submission_answer['value'][0];
          $user = isset($users[$voted_for]) ? $users[$voted_for] : user_load_by_name($voted_for);
          $users[$voted_for] = $user; // Save the user so we don't look them up repeatedly.
          // Add to the results table.
          $results[$position][$user->uid] = !empty($results[$position][$user->uid]) ?
            $results[$position][$user->uid] + 1 : 1;
        }
      }
    }
  }
  else {
    // No submissions yet. So enter zero for everyone.
    foreach ($node->webform['components'] as $cid => $component) {
      if ($component['form_key'] != 'additional_comments') {
        // Get the position key name.
        $position = $component['form_key'];
        // Enter a zero vote for user 1 to make sure position is available.
        $results[$position][1] = 0;
      }
    }
  }
  // Ok, now we have a 2d array of results.
  // Sort them so the first on the list are the winners.
  foreach ($results as $position => $candidates) {
    // And make sure each user who got a vote anywhere, is marked as having a value
    // In this table, even if it's just a zero.
    foreach ($users as $user) {
      if (empty($candidates[$user->uid])) {
        $candidates[$user->uid] = 0;
      }
    }
    // Now we want to preserve the associated key though, uid => #votes.
    // Just sort by # of votes - so an associated, reverse sort.
    arsort($candidates);
    $results[$position] = $candidates;
  }
  // Now that we have them sorted, return them.
  return $results;
}

/**
 * Helper function, create position fields on users given an array of position titles.
 */
function create_election_position_fields() {
  // Add the new position.
  $positions = _election_get_positions();
  foreach ($positions as $field_key_name => $position) {
    $existing_field = field_info_field('field_staff_' . $field_key_name);
    if (empty($existing_field)) {
      // Set up the data arrays.
      $field = array(
        'active' => '1',
        'cardinality' => '1',
        'deleted' => '0',
        'entity_types' => array(),
        'field_name' => 'field_staff_' . $field_key_name,
        'foreign keys' => array(),
        'indexes' => array(
          'value' => array(
            0 => 'value',
          ),
        ),
        'locked' => '0',
        'module' => 'list',
        'settings' => array(
          'allowed_values' => array(
            0 => 'No',
            1 => 'Yes',
          ),
          'allowed_values_function' => '',
        ),
        'translatable' => '0',
        'type' => 'list_boolean',
      );
      $instance = array(
        'bundle' => 'user',
        'default_value' => array(
          0 => array(
            'value' => 1,
          ),
        ),
        'deleted' => '0',
        'description' => t('I would like to be considered eligible for ' . $position . ' positions during elections.'),
        'display' => array(
          'default' => array(
            'label' => 'inline',
            'settings' => array(),
            'type' => 'list_boolean',
            'weight' => '6',
          ),
        ),
        'entity_type' => 'user',
        'field_name' => 'field_staff_' . $field_key_name,
        'label' => t('Eligible for ' . $position . ''),
        'required' => 0,
        'settings' => array(
          'user_register_form' => 0,
        ),
        'widget' => array(
          'active' => 1,
          'module' => 'options',
          'settings' => array(
            'display_label' => 1,
          ),
          'type' => 'options_onoff',
        ),
      );
      // Create the field.
      field_create_field($field);
      // Create the instance.
      field_create_instance($instance);
      // Update all existing users to have this field automatically turned on.
      db_query('REPLACE INTO {field_data_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      db_query('REPLACE INTO {field_revision_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      // Output message.
      drupal_set_message('Created user field instance: ' . $field_key_name);
    }
  }
  // Flush Entity Cache record.
  if (module_exists('entitycache')) {
    cache_clear_all('*', 'cache_entity_node', TRUE);
  }
}

/**
 * Helper function. Return an array of positions on site, assoc (form_key => human name).
 */
function _election_get_positions() {
  $saved_positions = variable_get('election_positions', '');
  $saved_positions = explode("\n", $saved_positions);
  $positions = array();
  foreach ($saved_positions as $postion) {
    $postion = trim($postion);
    if (!empty($postion)) {
      $key = preg_replace("/[^A-Za-z0-9_ ]/", '', $postion); // Remove all but space, underscore, and alphanumeric.
      $key = trim(str_replace(' ', '_', strtolower($key))); // Lowercase, replace spaces, trim.
      $positions[$key] = trim($postion);
    }
  }
  return $positions;
}

/**
 * Helper function, translate a human name into a key for field names.
 */
function get_field_key_name($position) {
  $positions = _election_get_positions();
  $key = array_keys($positions, trim($position));
  return !empty($key) ? $key[0] : FALSE;
}

/**
 * Helper function, translate a key into a human name for output.
 */
function get_field_human_name($key) {
  $positions = _election_get_positions();
  return !empty($positions[$key]) ? $positions[$key] : FALSE;
}

/**
 * CRUD function. Set or create election info for a node.
 */
function _election_update_election($election) {
  $data = (array) $election;
  if (!isset($data['nid'])) {
    return FALSE; // We must have a nid for this election data.
  }
  $old_data = _election_get_election_by_nid($data['nid']);
  if ($old_data) {
    $data = array_merge( (array) $old_data, $data);
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    drupal_write_record('election_nodes', $data, 'eid');
  }
  else {
    // New election post. Set the new cycle and open time.
    $cycle = _election_get_last_cycle();
    $cycle++;
    $data['cycle'] = !empty($data['cycle']) ? $data['cycle'] : $cycle;
    $data['opened'] = strtotime('now');
    $data['closed'] = -1;
    $data['winners'] = array();
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    // Write it.
    drupal_write_record('election_nodes', $data);
  }
  // Data returned on pointer, but just in case.
  return (object) $data;
}

/**
 * CRUD function. Get election info for an election.
 */
function _election_get_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  $data->positions = unserialize($data->positions);
  $data->winners = unserialize($data->winners);
  return $election;
}

/**
 * CRUD function. Get election info for a node.
 */
function _election_get_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {election_nodes} WHERE nid = :nid',
    array(':nid' => $nid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  if (!empty($election->positions)) {
    $election->positions = unserialize($election->positions);
  }
  if (!empty($election->winners)) {
    $election->winners = unserialize($election->winners);
  }
  return $election;
}

/**
 * CRUD function. Delete election info for a node.
 */
function _election_delete_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('DELETE FROM {election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
}

/**
 * CRUD function. Delete election info for a node.
 */
function _election_delete_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  db_query('DELETE FROM {election_nodes} WHERE nid = :nid',
    array(':nid' => $nid));
}

/**
 * DB function. Get the current max cycle.
 */
function _election_get_last_cycle() {
  $cycle = db_query('SELECT MAX(cycle) FROM {election_winners}')->fetchField();
  return !empty($cycle) ? $cycle : 1;
}

/**
 * CRUD function. Set or create election info for a node.
 */
function _election_mark_winner($winner) {
  $data = (array) $winner;
  if (empty($data['uid']) || empty($data['cycle']) || empty($data['position'])) {
    return FALSE; // We must have data for this election data.
  }
  // New election post. Set the new cycle and open time.
  drupal_write_record('election_winners', $data);
  // Data returned on pointer, but just in case.
  return (object) $data;
}
// NO DELETE FUNCTION. We do not remove records of elections to avoid messing up cycle count.

/**
 * DB function. Figure out if this user is at term limit.
 */
function _election_is_at_term_limit($uid, $term_limit, $position) {
  $current_cycle = _election_get_last_cycle();
  $cycle_limit = $current_cycle - $term_limit;
  $times_held = db_query('SELECT COUNT(uid) AS held FROM {election_winners} ' .
    'WHERE uid = :uid ' . 
    'AND position = :position ' .
    'AND cycle > :cycle',
    array(':uid' => $uid, ':position' => $position, ':cycle' => $cycle_limit))->fetchField();
  $times_held = !empty($times_held) ? $times_held : 0;
  if ($times_held < $term_limit) {
    return FALSE;
  }
  return TRUE;
}