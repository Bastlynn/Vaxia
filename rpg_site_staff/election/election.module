<?php
/**
 * @file
 * Code for Elections.
 */

/**
 * Implements hook_permission().
 */
function election_permission() {
  return array(
    'can vote on elections'=> array(
      'title' => t('can vote on elections'),
      'description' => t('Vote on elections.'),
    ),
    'administrate elections'=> array(
      'title' => t('administrate elections'),
      'description' => t('Administrate elections.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function election_menu() {
  $items['admin/vaxia/election'] = array(
    'title' => 'Election settings',
    'description' => 'Elections for administration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_election_admin_settings'),
    'access arguments' => array('administrate elections'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_rules_event_info().
 */
function election_rules_event_info() {
  $items = array(
    'open_election' => array(
      'label' => t('Election open'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
      ),
    ),
    'close_election' => array(
      'label' => t('Election close'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'ties' => array(
            'type' => 'list<text>',
            'label' => t('Ties'),
        ),
      ),
    ),
    'open_runoff_election' => array(
      'label' => t('Election runoff'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election runoff'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'ties' => array(
            'type' => 'list<text>',
            'label' => t('Ties'),
        ),
      ),
    ),
    'cancelled_election' => array(
      'label' => t('Election cancelled'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election cancelled'),
        ),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_node_delete().
 */
function election_node_delete($node) {
  // Delete an election associated with a proposal if we delete the node.
  if ($node->type == 'proposal') {
    _election_delete_election_by_nid($node->nid);
  }
}

/**
 * Implements hook_node_update().
 */
function election_node_update($node) {
  // Check a proposal for an election value.
  if ($node->type == 'proposal') {
    _election_election_check_close($node);
  }
}

/**
 * Implements hook_cron().
 */
function election_cron() {
  $last_run = variable_get('election_cron', 0);
  $yesterday = strtotime('-1 day');
  if ($last_run < $yesterday) {
    $today = date('m/d/Y');
    $today = strtotime($today . ' 00:00:01'); // We always want to plan to run just after midnight.
    variable_set('election_cron', $today);
    _election_cron_election();
  }
}

/**
 * Implements hook_cronapi().
 */
function election_cronapi($op, $job = NULL) {
  $items['_election_cron_election'] = array(
  	'description' => 'Election: Check election day',
  	'rule' => '1 0 * * *', // Once every day at 12:01 AM.
  );
  return $items;
}

/**
 * Cron handler for elections.
 */
function _election_cron_election() {
  $election_day = _election_check_election_day();
  if ($election_day) {
    // This is an official election! Time to get things sorted out.
    // First remove current heads from positions, put admin in for anon mailer.
    $role = variable_get('election_role', '');
    db_query('DELETE FROM {users_roles} WHERE rid = :rid',
      array(':uid' => $winner->uid, ':rid' => $role));
    $data = array('uid' => 1, 'rid' => $role);
    drupal_write_record('users_roles', $data);
    // And start the election.
    _election_trigger_election();
  }
}

/**
 * Helper function. Check if today is election day.
 */
function _election_check_election_day() {
  // Grab the info about the last election and when / how to run it.
  $last_held = variable_get('election_day', '5/1/2013');
  $rate = variable_get('election_rate', '1 year');
  // Based on the last election, get the next election in a standard format.
  $last_election = strtotime($last_held);
  $next_election = date('m/d/Y', strtotime($rate, $last_election));
  // Calculate today, see if it's the same values in a standard format.
  $today = date('m/d/Y', strtotime('now'));
  // Do they match? Mark today in the variables.
  if ($today == $next_election) {
    variable_set('election_day', date('m/d/Y'));
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter(). Remove the election fields from display or access if not eligable.
 */
function election_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  // If we're qualified, don't hide anything.
  $roles = variable_get('election_run_roles', '');
  foreach ($roles as $role) {
    if (in_array($role, array_keys($form['#user']->roles))) {
      // Do nothing.
      return;
    }
  }
  // Hide anything in the hidden fieldgroup.
  foreach (element_children($form) as $field_name) {
    if (strpos($field_name,'field_staff_') !== FALSE) {
      $form[$field_name]['#access'] = FALSE;
    }
  }
}

/**
 * Menu callback, admin form.
 */
function _election_admin_settings($form, &$form_state) {
  $form['election_day'] = array(
    '#title' => t('Last election day'),
    '#description' => t('The last-held election day for calculating further elections.'),
    '#type' => 'textfield',
    '#disabled' => TRUE,
    '#default_value' => variable_get('election_day', '5/1/2013'),
    '#value' => variable_get('election_day', '5/1/2013'),
  );
  $form['election_rate'] = array(
    '#title' => t('Election rate'),
    '#description' => t('How often to hold elections. Use timeframe formats strtotime will recognize.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_rate', '1 year'),
  );
  $form['election_term_limits'] = array(
    '#title' => t('Term limits'),
    '#description' => t('Use term limits when calculating eligable users for positions.'),
    '#type' => 'checkbox',
    '#default_value' => variable_get('election_term_limits', TRUE),
  );
  $form['election_term_limit_limits'] = array(
    '#title' => t('Term limit'),
    '#description' => t('How many consecutive (not lifetime) terms can a user serve in the same position.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_term_limit_limits', 2),
  );
  $form['election_run_roles'] = array(
    '#title' => t('Election run role'),
    '#description' => t('These roles are allowed to run.'),
    '#type' => 'select',
    '#multiple' => TRUE,
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_run_roles', array()),
  );
  $form['election_role'] = array(
    '#title' => t('Elected role'),
    '#description' => t('This role is considered the elected role. Election winners automatically recieve this role.'),
    '#type' => 'select',
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_role', ''),
  );
  $vid = variable_get('forum_nav_vocabulary', 0);
  $options = array();
  if ($terms = taxonomy_get_tree($vid)) {
    foreach ($terms as $term) {
      $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
    }
  }
  $form['election_default_forum'] = array(
    '#title' => t('Election forum'),
    '#description' => t('The default forum to post the election proposal in.'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => variable_get('election_default_forum', ''),
  );
  $intro_text = t('Each year we have an election for key positions on our site. ' .
    'This is so that we can always be sure that the current leadership is connected to ' .
    'and trusted by our players.');
  $form['election_election_intro'] = array(
    '#title' => t('Election intro'),
    '#description' => t('Election introduction text.'),
    '#type' => 'textarea',
    '#default_value' => variable_get('election_election_intro', $intro_text),
  );
  $positions = _election_get_positions();
  $available = implode("\n", $positions);
  if (empty($positions)) {
    $available = implode("\n", array('Setting Lead', 'System Lead', 'Social Lead') );
  }
  $form['election_positions'] = array(
    '#title' => t('Available positions'),
    '#description' => t('List postitions available on the site, one per row.'),
    '#type' => 'textarea',
    '#default_value' => $available,
  );
  $form['election_position_details'] = array(
    '#type' => 'fieldset',
    '#title' => t('Additional position details'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  foreach ($positions as $key => $human_name) {
    $form['election_position_details']['details_' . $key] = array(
      '#type' => 'fieldset',
      '#title' => $human_name,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['election_position_details']['details_' . $key]['election_position_count_' . $key] = array(
      '#type' => 'select',
      '#title' => t('How many slots in this position?'),
      '#options' => range(0,10),
      '#default_value' => variable_get('election_position_count_' . $key, 2),
    );
    $form['election_position_details']['details_' . $key]['election_position_desc_' . $key] = array(
      '#type' => 'textarea',
      '#title' => t('Additional description for the position.'),
      '#default_value' => variable_get('election_position_desc_' . $key, ''),
    );
  }
  $form['election_open_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Hold an election off-cycle'),
    '#submit' => array('_election_open_submit'),
  );
  $form['election_close_election'] = array(
    '#type' => 'submit',
    '#value' => t('Close open elections'),
    '#submit' => array('_election_close_submit'),
  );
  $form['#submit'][] = '_election_positions_submit';
  return system_settings_form($form);
}

/**
 * Submit callback, close open elections.
 */
function _election_close_submit($form, &$form_state) {
  // And get the correct timeframe assuming a start time of 2 weeks ago.
  $proposals = db_query('SELECT n.nid FROM {node} n ' .
    'LEFT JOIN webform w ON n.nid = w.nid ' .
    'WHERE n.type = \'proposal\' ' .
    'AND n.status = 1 ' .
    'AND w.status = 1 ');
  // Trigger event.
  foreach ($proposals as $proposal) {
    $election = _election_get_election_by_nid($proposal->nid);
    if ($election) {
      if (function_exists('rules_invoke_event')) {
        $node = node_load($proposal->nid);
        // Clear out the disallowed roles option for this proposal
        $disallowed = variable_get('proposal_disallowed_roles', array());
        if (isset($disallowed[ $node->nid ])) {
          unset($disallowed[ $node->nid ]);
        }
        variable_set('proposal_disallowed_roles', $disallowed);
        // Call the rules.
        rules_invoke_event('close_proposal', $node);
      }
    }
  }
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _election_open_submit($form, &$form_state) {
  // This is an official election! Time to get things sorted out.
  // First remove current heads from positions, put admin in for anon mailer.
  $elected_role = variable_get('election_role', '');
  // Remove current people from position.
  // This ONLY happens during election triggers like form or cron.
  // It does NOT happen on runoff elections.
  db_query('DELETE FROM {users_roles} WHERE rid = :rid', array(':rid' => $elected_role));
  // Set user one as the temporary position holder.
  $data = array('uid' => 1, 'rid' => $elected_role);
  drupal_write_record('users_roles', $data);
  // And start the election.
  variable_set('election_day', date('m/d/Y'));
  _election_trigger_election();
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _election_positions_submit($form, &$form_state) {
  // Grab the old positions.
  // TODO: For now, leave it to the admin to delete the old ones.
  // Grab the new positions from the settings.
  $positions = isset($form_state['values']['election_positions']) ?
    $form_state['values']['election_positions'] : '';
  $positions = explode("\n", $positions);
  $available = array();
  foreach ($positions as $index => $position) {
    $position = trim($position); // Trim.
    if (!empty($position)) {
      $available[] = $position;
    }
  }
  // Make sure to set the variable early so the position fields can use it.
  variable_set('election_positions', implode("\n", $available));
  // And create fields.
  if (!empty($available)) {
    create_election_position_fields();
  }
}

/**
 * Create an election set with all relevant data.
 * Title is optional, can be set to override default.
 * Postions optiona, can be set to override defaults in for example runoffs.
 * Election is the election object for tracking the cycle - for runoffs.
 */
function _election_trigger_election($title = '', $positions = array(), $election = array()) {
  // Make sure we have the right positions in place.
  create_election_position_fields();
  // Create the node.
  $title = !empty($title) ? $title : t('Site Election');
  $node->title = date('m/d/Y') . ' ' . $title;
  $node->type = 'proposal';
  $node->uid = 1;
  $node->language = 'und';
  // node_save($node);
  // Post to the correct forum.
  $tid = variable_get('election_default_forum', '');
  $node->taxonomy_forums[ $node->language ][0]['tid'] = !empty($tid) ? $tid : '';
  node_save($node);
  $node = node_load($node->nid);
  // Check that the node was properly created.
  if (!empty($node)) {
    // Ok, set up the webform elements for this election.
    _election_setup_election_proposal($node, $positions, $election);
  }
  // If we have rules, trigger it.
  if (function_exists('rules_invoke_event')) {
    rules_invoke_event('open_election', $node);
  }
}

/**
 * Helper function. Create an election webform with the right settings.
 */
function _election_setup_election_proposal($new_election, $positions = array(), $election = array()) {

  // Figure out the positions.
  // If we were passed positions for this election, use those. (Probably a runoff.)
  if (empty($positions)) {
    // Otherwise load the list from the stored variable.
    $positions = _election_get_positions();
  }

  // Trim up for possible bad input.
  foreach ($positions as $index => $position) {
    $position = trim($position);
    if (!empty($position)) {
      $positions[$index] = $position;
    }
  }

  // Set the webform body and basic configuration.
  $output = '';
  $output .= '<h3><b>' . t('Election') . '</b></h3>';
  $output .= '<p>' . variable_get('election_election_intro', '') . '</p>';
  $output .= '<p>' . t('Available positions are:') . '</p>';
  $output .= theme('item_list', array('items' => $positions));
  $output .= '</br><p>Please take a moment to review the candidates for this ' .
    'year and select those you feel to be the best choices for the available ' .
    'positions.</p>'.
    '<p>Where more than one winner for a position is allowed, select ' .
    'your set of top choices for each position. The winners will be selected from ' .
    'the combined results of all choices for the postion.</p>'.
    'The order of the votes doesn\'t matter - both candidates you pick for a given ' .
    'department go into the pool of votes evenly. Your A vote doesn\'t get any more ' .
    'weight than your B vote, so select them in any order you choose.</p>';
  $new_election->body[$new_election->language][0]['value'] = $output;
  // Set up the webform defaults if node hasn't yet.
  if (!isset($new_election->webform)) {
    $new_election->webform = webform_node_defaults();
  }
  $new_election->webform['confirmation'] = t('Thank you for participating!');
  $new_election->webform['confirmation_format'] = 'plain_text';
  $new_election->webform['submit_limit'] = 1;
  // Set approving roles for users based on all roles with 'can vote on elections' permission.
  $election_voting_roles = user_roles(FALSE, 'can vote on elections');
  $record = db_query('DELETE FROM {webform_roles} WHERE nid = :nid', array(':nid' => $new_election->nid));
  $roles = array();
  foreach ($election_voting_roles as $rid => $role) {
    if ($role) {
      $roles[] = $rid;
    }
  }
  // Set the default users.
  $new_election->webform['roles'] = $roles;
  _proposal_webform_set_users($roles, array(), $new_election->nid);
  // Set the status to ON on new elections.
  $new_election->webform['status'] = TRUE;
  node_save($new_election);

  // And now we mark this proposal as having been created in our site as an election object.
  $election_data = array(
    'nid' => $new_election->nid,
    'positions' => $positions,
    'closed' => -1,
    'winners' => array(),
  );
  $election_data = array_merge( (array) $election, $election_data); // Merge any existing election info.
  if (isset($election_data['eid'])) {
    // It's a runoff election, new node, but same cycle, same positions.
    unset($election_data['eid']);
  }
  $election_data = _election_update_election($election_data);

  // And now the fun part: set the components for the form.
  _election_setup_election_proposal_components($new_election, $positions, $election_data);

  // And set a message to our user.
  drupal_set_message(t('A new election has been created at !link.',
    array('!link' => l($new_election->title, 'node/' . $new_election->nid))));
}

/**
 * Helper function. Create the components for an election form.
 */
function _election_setup_election_proposal_components($new_election, $positions, $election_data) {
  // Include the webform module that allows components to be created.
  module_load_include('inc', 'webform', 'includes/webform.components');
  // Create the webform fields for possible elected.
  $weight = 0;
  $positions_ready = FALSE;
  $alphabet =   array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');
  foreach ($positions as $position) {
    // Get the key to use.
    $field_key_name = get_field_key_name($position);
    if ($field_key_name) {
      // Gather the user info.
      $run_roles = variable_get('election_run_roles', array());
      $run_roles = array_values($run_roles);
      $elected_role = variable_get('election_role', '');
      // This filter removes candidates from sligibility as follows:
      // They're in the role to run.
      // They DO NOT currently have a seat.
      // They haven't opted out.
      $candidates = db_query('SELECT DISTINCT u.name, u.uid FROM {users} u ' . 
        'LEFT JOIN {users_roles} ur ON u.uid = ur.uid ' .
        'LEFT JOIN {field_data_field_staff_' . $field_key_name . '} f ON u.uid = f.entity_id ' .
        'WHERE ur.rid IN (:run_roles) ' .
        'AND u.uid NOT IN (SELECT ur2.uid FROM users_roles ur2 WHERE ur2.rid IN (:elected_role) ) ' .
        'AND f.field_staff_' . $field_key_name . '_value = 1 ' .
        'ORDER BY u.name', // Alphabetical order.
        array(':run_roles' => $run_roles, ':elected_role' => $elected_role));

      // Check the user for eligabilty and term limits.
      $eligable_candidates = '';
      $term_limits = variable_get('election_term_limits', TRUE);
      $term_limits_limit = variable_get('election_term_limit_limits', 2);
      foreach ($candidates as $candidate) {
        $eligable = TRUE;
        if ($term_limits) {
          // Check for this position key if the user has the ok or if they need to lay off for a bit.
          $eligable = !_election_is_at_term_limit( $candidate->uid, $term_limits_limit, $field_key_name);
        }
        // If we're still ok, add em.
        if($eligable) {
          $eligable_candidates .= $candidate->name . '|' . $candidate->name . "\n";
        }
      }

      // Create the component for the position IF we have any eligable candidates.
      if (!empty($eligable_candidates)) {
        // Get and insert the description.
        $desc = variable_get('election_position_desc_' . $field_key_name, '');
        $desc = trim($desc);
        if (!empty($desc)) {
          $component = array();
          $component['nid'] = $new_election->nid;
          $component['pid'] = 0;
          $component['form_key'] = $field_key_name . '_not_position'; // Use the position fieldname as the key.
          $component['name'] = $position;
          $component['type'] = 'markup';
          $component['mandatory'] = 0;
          $component['value'] = $desc;
          $component['extra'] = array(
            'format' => 'filtered_html',
            'private' => 0,
          );
          $component['weight'] = $weight;
          $weight++;
          webform_component_insert($component);
        }
        // Find out if we're doing doubles or not.
        $slots = variable_get('election_position_count_' . $field_key_name, 2);
        // For every slot we have, where we do not already have someone locked in.
        // Then we run the election for that slot.
        $currently_held = _election_get_current_holders($field_key_name, $election_data->cycle);
        for ($i = 0; $i < $slots; $i++) {
          if ($i < count($currently_held)) {
            $component = array();
            $component['nid'] = $new_election->nid;
            $component['pid'] = 0;
            $component['form_key'] = $field_key_name . '_not_position'; // Use the position fieldname as the key.
            $component['name'] = $position . ' ' . strtoupper($alphabet[$i]);
            $component['type'] = 'markup';
            $component['mandatory'] = 0;
            $component['value'] = $position . ' ' . strtoupper($alphabet[$i]) . ': '. t('is currently held by ' . $currently_held[$i]->name . '.');
            $component['extra'] = array(
              'format' => 'filtered_html',
              'private' => 0,
            );
            $component['weight'] = $weight;
            $weight++;
            webform_component_insert($component);
          }
          else {
            $component = array();
            $component['nid'] = $new_election->nid;
            $component['pid'] = 0;
            $component['form_key'] = $field_key_name . '_' . $alphabet[$i]; // Use the position fieldname as the key.
            $component['name'] = $position . ' ' . strtoupper($alphabet[$i]);
            $component['type'] = 'select';
            $component['mandatory'] = 0;
            $component['extra'] = array(
              'description' => '',
              'items' => $eligable_candidates,
              'multiple' => '0',
              'aslist' => '1',
            );
            $component['weight'] = $weight;
            $weight++;
            webform_component_insert($component);
            $positions_ready = TRUE;
          }
        }
      }
      else {
        $component = array();
        $component['nid'] = $new_election->nid;
        $component['pid'] = 0;
        $component['form_key'] = $field_key_name . '_not_position'; // Use the position fieldname as the key.
        $component['name'] = $position;
        $component['type'] = 'markup';
        $component['mandatory'] = 0;
        $component['value'] = $position . ' ' . strtoupper($alphabet[$i]) . ': '. t('There are no eligable candidates for ' . $position . '.');
        $component['extra'] = array(
          'format' => 'filtered_html',
          'private' => 0,
        );
        $component['weight'] = $weight;
        $weight++;
        webform_component_insert($component);
        watchdog('election', 'This election has no candidates for ' . $position . '.');
        drupal_set_message(t('This election has no candidates for ' . $position . '.'));
      }
    } // Done with the if for each position key name.
  } // Done with loop for positions.

  // If we didn't find anyone for any of these positions we really don't
  // have enough people for an election. This is an EMERGENCY situation
  // that we should mark as such - also we close the election right now
  // to avoid triggering any future looping until we're ready to elect.
  if (!$positions_ready) {
    // Reload the election before saving any changes to make sure we don't
    // zap any components that were placed on it since the last load.
    $new_election = node_load($new_election->nid);
    $new_election->title .= ' ' . t('(Cancelled)');
    $new_election->status = 0; // TMP hiden from view.
    $new_election->webform['status'] = FALSE;
    watchdog('election', 'This election has no candidates for ANY position. It has been automatically closed without runoff.');
    drupal_set_message(t('This election has no candidates for ANY position. It has been automatically closed without runoff.'), 'error');
    node_save($new_election);
    // And set rule to trigger in case of a cancelled election.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('cancelled_election', $new_election);
    }
  }
  else {
    // Copy from proposal.module - include the comment field.
    $component = array();
    $component['nid'] = $new_election->nid;
    $component['pid'] = 0;
    $component['form_key'] = 'additional_comments';
    $component['name'] = t('Additional Comments');
    $component['type'] = 'textarea';
    $component['mandatory'] = 0;
    $component['extra'] = array();
    $component['weight'] = 1000;
    webform_component_insert($component);
  }
}

/**
 * Handle when we close an election. Called on proposal close.
 */
function _election_election_check_close($node) {
  $election = _election_get_election_by_nid($node->nid);
  // Check if we are closed. If we aren't an election this returns nothing.
  if ($election && $election->closed == -1 && $node->webform['status'] == FALSE) {

    // Close the election.
    $election->closed = strtotime('now');
    $election->winners = array();
    $elected_role = variable_get('election_role', '');
    // And save this election as done.
    _election_update_election($election);
    // Read the results into a readable array.
    // These are merged results, to get the top winners from all positions given.
    $results = _election_get_results($node);
    // Gather winners and set them up.
    $winners = _election_get_winners($node, $results); // Return as assoc array.
	if (!empty($winners)) {
      // User one is no longer required to operated as a temporary position.
      db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
        array(':uid' => 1, ':rid' => $elected_role));
      // Now process the winners, marking them for terms etc as needed.
      foreach ($winners as $winner => $position) {
        // Add the winner to the heads role.
        db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
          array(':uid' => $winner, ':rid' => $elected_role));
        $data = array('uid' => $winner, 'rid' => $elected_role);
        drupal_write_record('users_roles', $data);
        // And for each winner, mark that they've been assigned for this cycle to this position.
        $this_winner = _election_mark_winner(array(
          'uid' => $winner,
          'cycle' => $election->cycle,
          'position' => $position,
        ));
      }
      // Add to the election information recorded so far.
      $election->winners = $winners;
    }

    // Gather ties and set up a runoff.
    $ties = _election_get_ties($node, $results, $winners); // Return as assoc array.
	if (!empty($ties)) {
      // We need to run a tie breaker election with JUST these postions.
      // So we open ANOTHER election, not the same one.
      // Technically this could go on forever.
      _election_trigger_election(t('Site Run-off Election'), $ties, $election);
      // If we have rules, trigger it.
      if (function_exists('rules_invoke_event')) {
        rules_invoke_event('open_runoff_election', $node, array_keys($winners), $ties);
      }
    }

    // And save this election as done.
    _election_update_election($election);
    // If we have rules, trigger it.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('close_election', $node, array_keys($winners), $ties);
    }
  }
}

/**
 * Helper function, given an election node figure out who the winners are.
 */
function _election_get_winners($node, $results) {
  // Save the original results to pass up to other systems.
  $orig_results = $results;

  // Take the greatest or equal to greatest votes only.
  // This allows the site opnion on wanting a candidate for more
  // than one position to be the deciding factor on which position
  // they will ultimately recieve. Order doesn't matter here.
  $max_votes = array();
  foreach ($results as $position => $candidates) {
    foreach ($candidates as $uid => $vote_got) {
      // Make sure it's set.
      $max_votes[$uid] = isset($max_votes[$uid]) ? $max_votes[$uid] : 0;
      // See if this one is higher than the other one.
      if ($vote_got < $max_votes[$uid]) {
        // If this position is less than the max, zero it.
        $results[$position][$uid] = 0;
      }
      else {
        // If this position is equal or greater set value, save and ignore.
        $max_votes[$uid] = $vote_got;
      }
    }
  }

  // And now do the recursion to figure out who wins out in which position.
  // Order matters here because we're checking against slots.
  // Reorder the positions so winners are up front.
  $positions = array();
  foreach ($results as $position => $candidates) {
    // Now we want to preserve the associated key though, uid => #votes.
    // Just sort by # of votes - so an associated, reverse sort.
    arsort($candidates);
    $results[$position] = $candidates;
    // Figure out how many slots we have in this position.
    $positions[$position] = variable_get('election_position_count_' . $position, 2);
  }
  // Order our list of positions to process by smallest # of slots to greatest.
  // That will prioritize the roles given to the slots than need them more.
  // Now we want to preserve the associated key though, position_name => slot.
  asort($positions);

  // Use positions as the control. Once we're out of positions to sort, we're done.
  $results = _election_get_winners_by_position($results, $positions);

  // Remove anything that's a zero from the results.
  $found_results = $results;
  foreach ($found_results as $position => $candidates) {
    // Check each candidate, and remove zeros from the results.
    foreach ($candidates as $uid => $votes) {
      if ($votes == 0) {
        unset($results[$position][$uid]);
      }
    }
  }

  // It might be a tie. If so, lets remove anyone who would be unclear.
  $found_results = $results;
  foreach ($found_results as $position => $candidates) {
    // Get the least value, should be greater than zero now.
    $least_votes = min($candidates);
    // Check each candidate, and remove zeros from the results.
    foreach ($candidates as $uid => $votes) {
      // Remove all the lag-behinds from the winners.
      // This will bring us to less than the required number of slots.
      // So that the competion for the last slot can be in the run-off.
      if ($votes == $least_votes) {
        unset($results[$position][$uid]);
      }
    }
  }

  // Ok, we now have as completely clipped a set of positions as humanly possible.
  // Lets get our winners out of there, ok?
  $won_positions = array();
  foreach ($results as $position => $candidates) {
    foreach ($candidates as $uid => $votes) {
      $won_positions[$position][] = $uid;
    }
  }
  // So we should have no unclear positions left. Now we map winners to positions for return.
  $winners = array();
  foreach ($won_positions as $won_position => $candidates) {
    foreach ($candidates as $candidate) {
      $winners[$candidate] = $won_position;
    }
  }

  // NOTE: THIS IS A SIMPLE ELECTION MECHANIC. (yes. I know.)
  // Aka, he with the most votes wins.
  // This does NOT require minimum # of voters to participate. Or min % of the vote
  // for the winner to be marked with the lead position and ready to go.
  // This is not nessecarily ideal! So we should ABSOLUTELY allow for hook overrides here.
  // So that more than one voting winner may be determined.
  drupal_alter('election_winners', $winners, $orig_results, $node);
  // To modify the election results, call hook_election_winners_alter(&$winners, $results, $node);
  return $winners;
}

/**
 * Helper function, given an election node figure out who the winners are.
 */
function _election_get_ties($node, $results, $winners) {
  // Map components to head positions.
  $ties = array();
  foreach ($results as $position => $candidates) {
    $slots = variable_get('election_position_count_' . $position, 2);
    $position_winners = array_keys($winners, $position);
    // If the position has more winners or less winners than it needs.
    // We will have runoffs if don't have EXACTLY the numbers we need.   
    if ($slots != count($position_winners)) {
      $hn_position = get_field_human_name($position);
      if ($hn_position) {
        $ties[] = $hn_position; // ALL candidates go up for the re-election vote, no need to set values here.
        watchdog('election', 'This election has a TIE for ' . $hn_position . '. Another follow-up should be run.');
        drupal_set_message(t('This election has a TIE for ' . $hn_position . '. Another follow-up should be run.'));
      }
    }
  }
  return $ties;
}

/**
 * Recursive function, determine who the winner is.
 */
function _election_get_winners_by_position($results, $positions) {

  // Now we check for any results across the 'line' of accepted positions.
  // If there are clear accepted spots for the slots given, we clear all other
  // positions for that user and accept the given position winners.
  // This does mean, by sheer accident of position, that preference is given
  // For the first position in the list if there is otherwise two clear positions.
  // This also means we need to reorder after EACH clear of a position.
  foreach ($positions as $position => $slots) {

    // First figure out if this position is a clearly defined one or not.
    $candidates = $results[$position];
    // If we have more slots than candidates then ANY vote is a win.
    $least_winning_vote = isset($candidates[$slots - 1]) ? $candidates[$slots - 1] : 1;
    $possible_winners = $possible_losers = array();
    foreach ($candidates as $uid => $vote_got) {
      // Only count non-zero votes for this. If zero, then anywhere else is better.
      if ($vote_got >= $least_winning_vote && $vote_got > 0) {
        $possible_winners[] = $uid;
      }
      else {
        $possible_losers[] = $uid;
      }
    }

    // We may have less than or just enough winners for a specific position.
    if ($slots <= count($possible_winners)) {
      // Modify the lesser results of this position to lock in values.
      foreach ($possible_losers as $uid) {
        $results[$position][$uid] = 0;
      }
      // At this point the site doesn't care if these people are in one role or the other
      // role. But since they can't have both, they'll have to go with the one that's
      // in more need of them than the others. So we clear that user in all other positions.
      // This is why we are looking at narrow slots first.
      foreach ($positions as $other_position => $other_slots) {
        if ($other_position != $position) {
          // Modify the results of other positions.
          foreach ($possible_winners as $uid) {
            $results[$other_position][$uid] = 0;
          }
        }
      }
      // But now that we have changed the content of results.
      // We have to start over again from the smallest to largets, but we can
      // safely ignore the one we just processed. We have to order it first.
      foreach ($results as $this_position => $candidates) {
        // Now we want to preserve the associated key though, uid => #votes.
        // Just sort by # of votes - so an associated, reverse sort.
        arsort($candidates);
        $results[$this_position] = $candidates;
      }
      // Figure out the positions left to go.
      $child_positions = $positions;
      unset($child_positions[$position]);
      // Use positions as the control. Once we're out of positions to sort, we're done.
      if (!empty($child_positions)) {
        $results = _election_get_winners_by_position($results, $child_positions);
      }
    } // End if slot has enough children.

  } // End processing for each position.

  // Ok, at this point we have clipped and consolidated as much of the results as we can.
  return $results;
}

/**
 * Helper function, summarize election results in a readable array.
 */
function _election_get_results($node) {
  // Include the webform file we need.
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  // Local cache of looked up users by name.
  $users = array();
  // Get submission results and put into a format for review.
  $submissions = webform_get_submissions($node->nid);
  $results = array();
  // Find out if we're doing doubles or not.
  $doubles = variable_get('election_positions_redundant', TRUE);
  if (!empty($submissions)) { 
    // And process the submissions for results.
    // If we are in doublemode we put both sets of results in the 
    // same bucket so that the top two elected from both A and B win.
    foreach ($submissions as $sid => $submission) {
      // Process each submission.
      foreach ($submission->data as $cid => $submission_answer) {
        // Process each position for each compontent.
        $component = $node->webform['components'][$cid];
        if ($component['form_key'] != 'additional_comments') {
          // Get the position key name.
          // If we're in double mode here, this will return a '_X' value.
          $position = ($doubles) ? substr( $component['form_key'], 0, -2) : $component['form_key'];
          // Get the user. NOTE this is the user's name, not uid.
          $voted_for = $submission_answer['value'][0];
          $user = isset($users[$voted_for]) ? $users[$voted_for] : user_load_by_name($voted_for);
          $users[$voted_for] = $user; // Save the user so we don't look them up repeatedly.
          // Add to the results table.
          $results[$position][$user->uid] = !empty($results[$position][$user->uid]) ?
            $results[$position][$user->uid] + 1 : 1;
        }
      }
    }
  }
  else {
    // No submissions yet. So enter zero for everyone.
    foreach ($node->webform['components'] as $cid => $component) {
      // If this is a position component, not additional or a markup saying non available.
      if ($component['form_key'] != 'additional_comments' && strpos($component['form_key'], '_not_position') === FALSE) {
        // Get the position key name.
        // If we're in double mode here, this will return a '_X' value.
        $position = ($doubles) ? substr( $component['form_key'], 0, -2) : $component['form_key'];
        // Enter a zero vote for user 1 to make sure position is available.
        $results[$position][1] = 0;
      }
    }
  }

  // And make sure each user who got a vote anywhere, is marked as having a value
  // In this table, even if it's just a zero.
  foreach ($results as $position => $candidates) {
    foreach ($users as $user) {
      if (empty($candidates[$user->uid])) {
        $candidates[$user->uid] = 0;
      }
    }
  }
  // Remove the non-vote candidate early.
  foreach ($results as $position => $candidates) {
    if (isset($results[$position][0])) {
      unset($results[$position][0]); // Candidate 'zero' is no-vote-cast.
    }
  }
  return $results;
}

/**
 * Helper function, create position fields on users given an array of position titles.
 */
function create_election_position_fields() {
  // Add the new position.
  $positions = _election_get_positions();
  foreach ($positions as $field_key_name => $position) {
    $existing_field = field_info_field('field_staff_' . $field_key_name);
    if (empty($existing_field)) {
      // Set up the data arrays.
      $field = array(
        'active' => '1',
        'cardinality' => '1',
        'deleted' => '0',
        'entity_types' => array(),
        'field_name' => 'field_staff_' . $field_key_name,
        'foreign keys' => array(),
        'indexes' => array(
          'value' => array(
            0 => 'value',
          ),
        ),
        'locked' => '0',
        'module' => 'list',
        'settings' => array(
          'allowed_values' => array(
            0 => 'No',
            1 => 'Yes',
          ),
          'allowed_values_function' => '',
        ),
        'translatable' => '0',
        'type' => 'list_boolean',
      );
      $instance = array(
        'bundle' => 'user',
        'default_value' => array(
          0 => array(
            'value' => 1,
          ),
        ),
        'deleted' => '0',
        'description' => t('I would like to be considered eligible for ' . $position . ' positions during elections.'),
        'display' => array(
          'default' => array(
            'label' => 'inline',
            'settings' => array(),
            'type' => 'list_boolean',
            'weight' => '6',
          ),
        ),
        'entity_type' => 'user',
        'field_name' => 'field_staff_' . $field_key_name,
        'label' => t('Eligible for ' . $position . ''),
        'required' => 0,
        'settings' => array(
          'user_register_form' => 0,
        ),
        'widget' => array(
          'active' => 1,
          'module' => 'options',
          'settings' => array(
            'display_label' => 1,
          ),
          'type' => 'options_onoff',
        ),
      );
      // Create the field.
      field_create_field($field);
      // Create the instance.
      field_create_instance($instance);
      // Update all existing users to have this field automatically turned on.
      db_query('REPLACE INTO {field_data_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      db_query('REPLACE INTO {field_revision_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      // Output message.
      drupal_set_message('Created user field instance: ' . $field_key_name);
    }
  }
  // Flush Entity Cache record.
  if (module_exists('entitycache')) {
    cache_clear_all('*', 'cache_entity_node', TRUE);
  }
}

/**
 * Helper function. Return an array of positions on site, assoc (form_key => human name).
 */
function _election_get_positions() {
  $saved_positions = variable_get('election_positions', '');
  $saved_positions = explode("\n", $saved_positions);
  $positions = array();
  foreach ($saved_positions as $postion) {
    $postion = trim($postion);
    if (!empty($postion)) {
      $key = preg_replace("/[^A-Za-z0-9_ ]/", '', $postion); // Remove all but space, underscore, and alphanumeric.
      $key = trim(str_replace(' ', '_', strtolower($key))); // Lowercase, replace spaces, trim.
      $positions[$key] = trim($postion);
    }
  }
  return $positions;
}

/**
 * Helper function, translate a human name into a key for field names.
 */
function get_field_key_name($position) {
  $positions = _election_get_positions();
  $key = array_keys($positions, trim($position));
  return !empty($key) ? $key[0] : FALSE;
}

/**
 * Helper function, translate a key into a human name for output.
 */
function get_field_human_name($key) {
  $positions = _election_get_positions();
  return !empty($positions[$key]) ? $positions[$key] : FALSE;
}

/**
 * CRUD function. Set or create election info for a node.
 */
function _election_update_election($election) {
  $data = (array) $election;
  if (!isset($data['nid'])) {
    return FALSE; // We must have a nid for this election data.
  }
  $old_data = _election_get_election_by_nid($data['nid']);
  if ($old_data) {
    $data = array_merge( (array) $old_data, $data);
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    drupal_write_record('election_nodes', $data, 'eid');
  }
  else {
    // New election post. Set the new cycle and open time.
    $cycle = _election_get_last_cycle();
    $cycle++;
    $data['cycle'] = !empty($data['cycle']) ? $data['cycle'] : $cycle;
    $data['opened'] = strtotime('now');
    $data['closed'] = -1;
    $data['winners'] = array();
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    // Write it.
    drupal_write_record('election_nodes', $data);
  }
  // Data returned on pointer, but just in case.
  return (object) $data;
}

/**
 * CRUD function. Get election info for an election.
 */
function _election_get_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  $data->positions = unserialize($data->positions);
  $data->winners = unserialize($data->winners);
  return $election;
}

/**
 * CRUD function. Get election info for a node.
 */
function _election_get_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {election_nodes} WHERE nid = :nid',
    array(':nid' => $nid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  if (!empty($election->positions)) {
    $election->positions = unserialize($election->positions);
  }
  if (!empty($election->winners)) {
    $election->winners = unserialize($election->winners);
  }
  return $election;
}

/**
 * CRUD function. Delete election info for a node.
 */
function _election_delete_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('DELETE FROM {election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
}

/**
 * CRUD function. Delete election info for a node.
 */
function _election_delete_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  db_query('DELETE FROM {election_nodes} WHERE nid = :nid',
    array(':nid' => $nid));
}

/**
 * DB function. Get the current max cycle.
 */
function _election_get_last_cycle() {
  $cycle = db_query('SELECT MAX(cycle) FROM {election_winners}')->fetchField();
  return !empty($cycle) ? $cycle : 1;
}

/**
 * CRUD function. Set or create election info for a node.
 */
function _election_mark_winner($winner) {
  $data = (array) $winner;
  if (empty($data['uid']) || empty($data['cycle']) || empty($data['position'])) {
    return FALSE; // We must have data for this election data.
  }
  // New election post. Set the new cycle and open time.
  drupal_write_record('election_winners', $data);
  // Data returned on pointer, but just in case.
  return (object) $data;
}
// NO DELETE FUNCTION. We do not remove records of elections to avoid messing up cycle count.

/**
 * DB function. Set or create election info for a node.
 */
function _election_get_current_winners($position) {
  $current_cycle = _election_get_last_cycle();
  $winners = db_query('SELECT uid FROM {election_winners} ' .
    'WHERE position = :position ' .
    'AND cycle = :cycle',
    array(':position' => $position, ':cycle' => $current_cycle));
  $users = array();
  foreach ($winners as $winner) {
    $users[] = user_load($winner->uid);
  }
  return $users;
}

/**
 * DB function. Set or create election info for a node.
 */
function _election_get_current_holders($position, $cycle) {
  $winners = db_query('SELECT uid FROM {election_winners} ' .
    'WHERE position = :position ' .
    'AND cycle = :cycle',
    array(':position' => $position, ':cycle' => $cycle));
  $users = array();
  foreach ($winners as $winner) {
    $users[] = user_load($winner->uid);
  }
  return $users;
}

/**
 * DB function. Figure out if this user is at term limit.
 */
function _election_is_at_term_limit($uid, $term_limit, $position) {
  $current_cycle = _election_get_last_cycle();
  $cycle_limit = $current_cycle - $term_limit;
  $times_held = db_query('SELECT COUNT(uid) AS held FROM {election_winners} ' .
    'WHERE uid = :uid ' . 
    'AND position = :position ' .
    'AND cycle > :cycle',
    array(':uid' => $uid, ':position' => $position, ':cycle' => $cycle_limit))->fetchField();
  $times_held = !empty($times_held) ? $times_held : 0;
  if ($times_held < $term_limit) {
    return FALSE;
  }
  return TRUE;
}