<?php
/**
 * @file
 * Provide a clean UI for scene records from a player crafter PoV.
 */

include_once 'scene_record.features.inc';

/**
 * Implements hook_permission().
 */
function scene_record_permission() {
  return array(
    'use scene helper' => array(
      'title' => t('use scene helper'),
      'description' => t('Use scene helper.'),
    ),
    'administer scene helper' => array(
      'title' => t('administer scene helper'),
      'description' => t('Administer scene helper.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function scene_record_menu() {
  $items['vaxia/scene_record/autocomplete/room'] = array(
    'title' => 'Scene record assist room lookup',
    'type' => MENU_CALLBACK,
    'page callback' => '_scene_record_autocomplete_room',
    'access arguments' => array('use scene helper'),
  );
  $items['admin/vaxia/scene_record'] = array(
    'title' => 'Scene record settings',
    'description' => 'Configure content type association settings for scene records.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_scene_record_admin_settings'),
    'access arguments' => array('administer scene helper'),
  );
  return $items;
}

/**
 * Implements hook_node_insert().
 */
function scene_record_node_insert($node) {
  scene_record_node_update($node);
}

/**
 * Implements hook_node_update().
 */
function scene_record_node_update($node) {
  $scene_type = variable_get('scene_record_scene_type', '');
  if (!empty($scene_type) && $scene_type == $node->type) {  
    $nid = $node->nid;
    // Collect content info.
    $save_comments = !empty($node->included_comments_table)
      ? $node->included_comments_table : array();
    // Save each one to the nid.
    if (empty($save_comments)) {
      return;
    }
    foreach ($save_comments as $cid => $comment) {
      // If marked, and not already in the list, add it.
      $this_comment = (object) $comment;
      $this_comment->nid = $nid;
      $this_comment->cid = $cid;
      $save_comments[$cid] = $this_comment;
    }
    foreach ($save_comments as $cid => $scene_comment) {
      // Don't save what's marked for removal.
      if ($scene_comment->remove == 0) {
        _scene_record_update_comment($scene_comment);
      }
    }
    // If a table with states, grab and render the info as a table.
    // And save it to our record fields to disconnect the record from comment.
    $set_comments = _scene_record_get_comments($node->nid);
    if (!empty($set_comments)) {
      // This function sets the value of headers and rows.
      _scene_record_view_table($headers, $rows, $node, $set_comments, TRUE);
      $table['value'] = theme('table', array('header' => $headers, 'rows' => $rows));
      $table['format'] = 'full_html';
      $node->field_scene[$node->language][0] = $table;
      field_attach_update('node', $node);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function scene_record_node_delete($node) {
  _scene_record_delete_comments($node->nid);
}

/**
 * Implements hook_comment_delete().
 */
function scene_record_comment_delete($comment) {
  _scene_record_delete_comment($comment->nid, $comment->cid);
}

/**
 * Return a display of the info as a renderable form.
 */
function _scene_record_view_table(&$headers, &$rows, $node, $set_comments, $full_text = FALSE) {
  $headers = array(
    t('Scene posts'),
    t('Results'),
  );
  $rows = array();
  // Create table data.
  $found_comments = array();
  foreach ($set_comments as $set_comment) {
    $found_comments[$set_comment->cid] = $set_comment;
  }
  // One last organization of all of these by cid.
  ksort($found_comments);
  // Get values.
  $found_comments = _scene_record_calculate_results($found_comments);
  // Loop for display.
  foreach ($found_comments as $cid => $scene_comment) {
    // Get comment display.
    $comment = comment_load($cid);
    if (is_object($comment) && !empty($comment->cid)) {
      $comment_uri = comment_uri($comment);
      if ($full_text) {
        $character = !empty($comment->field_comment_character[$comment->language][0]['nid']) ?
          node_load($comment->field_comment_character[$comment->language][0]['nid']) : '';
        if (empty($character)) {
          $user = user_load($comment->uid);
          $comment_by = $user->name;
        }
        else {
         $comment_by = $character->title;
        }
        $comment_display = check_markup($comment->comment_body[$comment->language][0]['value'], $comment->comment_body[$comment->language][0]['format']);
        if (!empty($comment->field_ooc[$comment->language][0]['value'])) {
          $comment_ooc = check_markup($comment->field_ooc[$comment->language][0]['value'], $comment->field_ooc[$comment->language][0]['format']);
          $comment_display .= 'OOC: ' . $comment_ooc;
        }
      }
      // Get dice display.
      $dice_rolls = _dice_roller_get_roll($cid, 'c');
      $comment_display .= !empty($dice_rolls) ? theme('dice_roller_results', array('dice_rolls' => $dice_rolls)) : '';
      // Add to rows.
      $rows[] = array(
        $comment_display,
        array(
        'data' => $scene_comment->results,
        'nowrap' => array('nowrap'),
        ),
      );
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function scene_record_form_node_form_alter(&$form, &$form_state, $form_id) {
  $scene_type = variable_get('scene_record_scene_type', '');
  if (!empty($scene_type) && !empty($form['#node']->type) && $scene_type == $form['#node']->type) {
    // Collapsible interface.
    $form['scene_record'] = array(
      '#type' => 'fieldset',
      '#title' => t('Scene Assistant'),
      '#description' => t('Use this assistant to attach scene posts.'),
      '#collapsible' => TRUE,
    );
    // Part one, add more comments.
    $form['scene_record']['add_comments'] = array(
      '#type' => 'fieldset',
      '#title' => t('Add new posts'),
      '#description' => t('Search for posts by room. Select the posts to save for this scene.'),
      '#collapsible' => TRUE,
    );
    $form['scene_record']['add_comments']['search_room'] = array(
      '#title' => t('Posts from room'),
      '#type' => 'textfield',
      '#autocomplete_path' => 'vaxia/scene_record/autocomplete/room',
      '#ajax' => array(
        'callback' => '_scene_record_ajax_load_room_comments',
        'wrapper' => 'scene-record-add-comments-table',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );
    $room = !empty($form_state['values']['search_room']) ? $form_state['values']['search_room'] : '';
    $options = array();
    if (!empty($room)) {
      $room_nid = _scene_record_autocomplete_get_nid($room);
      if ($room_nid != FALSE) {
        $found_comments = _scene_record_get_comments_by_room($room_nid);
        foreach ($found_comments as $found_comment) {
          $comment = comment_load($found_comment->cid);
          $comment_uri = comment_uri($comment);
          // Get the full text.
          $comment_text = '';
          if (!empty($comment->comment_body[$comment->language][0]['value'])) {
            $comment_text = check_markup($comment->comment_body[$comment->language][0]['value'], $comment->comment_body[$comment->language][0]['format']);
          }
          $comment_ooc = '';
          if (!empty($comment->field_ooc[$comment->language][0]['value'])) {
            $comment_ooc = check_markup($comment->field_ooc[$comment->language][0]['value'], $comment->field_ooc[$comment->language][0]['format']);
          }
          // Strip HTML - we can't use it in title overheads.
          $comment_text = strip_tags($comment_text);
          $comment_ooc = strip_tags($comment_ooc);
          $comment_title = check_plain($comment_text);
          if (!empty($comment_ooc)) {
            $comment_title .= "\n" . 'OOC: ' . check_plain($comment_ooc);
          }
          // Put together.
          $comment_display = '<a href="/' . $comment_uri['path'] . '#' . $comment_uri['options']['fragment'] . '" title="' . $comment_title . '">' .
            check_plain($comment->subject) . '</a>';
          // Get the rest.
          $character = !empty($comment->field_comment_character[$comment->language][0]['nid']) ?
            $comment->field_comment_character[$comment->language][0]['nid'] : '';
          $character = node_load($character);
          $character_name = !empty($character->title) ? $character->title : '';
          $dice_rolls = _dice_roller_get_roll($found_comment->cid, 'c');
          $dice_rolls = !empty($dice_rolls)
            ? theme('dice_roller_results', array('dice_rolls' => $dice_rolls))
            : t('No rolls found');
          $options[$found_comment->cid] = array(
            $comment_display,
            check_plain($character_name),
            check_plain($comment->name),
            date('m/d/Y H:i:s', $comment->changed),
          );
        }
      }
    }
    $form['scene_record']['add_comments']['add_comments_table'] = array(
      '#prefix' => '<div id="scene-record-add-comments-table">',
      '#suffix' => '</div>',
      '#type' => 'tableselect',
      '#header' => array(
        t('Posts'),
        t('Character'),
        t('Player'),
        t('Date'),
      ),
      '#options' => $options,
      '#js_select' => FALSE,
      '#multiple' => TRUE,
      '#empty' => t('No posts found.'),
    );
    $form['scene_record']['add_comments']['add'] = array(
      '#type' => 'button',
      '#value' => t('Add Posts'),
      '#limit_validation_errors' => array(array('add_comments_table'), array('included_comments_table')),
      // DOUBLE ARRAY. Because drupal docs suck.
      '#ajax' => array(
        'callback' => '_scene_record_ajax_add_comments',
        'wrapper' => 'scene-record-included-comments-table',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );
    // Part two, included comment.
    $form['scene_record']['included_comments'] = array(
      '#type' => 'fieldset',
      '#title' => t('Included posts'),
      '#collapsible' => TRUE,
    );
    // Setup table format.
    $form['scene_record']['included_comments']['included_comments_table'] = array(
      '#prefix' => '<div id="scene-record-included-comments-table">',
      '#suffix' => '</div>',
      '#theme' => 'table',
      '#header' => array(
        t('Scene posts'),
        t('Results'),
        t('(X)'),
      ),
      '#rows' => array(),
      '#attributes' => array('id' => 'scene_record_included_comments_table'),
      '#empty' => t('No posts found.'),
      '#tree' => TRUE, // So can be picked up later.
    );
    // Gather comments for display from various sources.
    $found_comments = array();
    // Check for comments still saved on the node.
    if (!empty($form['#node']->nid)) {
      $set_comments = _scene_record_get_comments($form['#node']->nid);
      foreach ($set_comments as $set_comment) {
        $found_comments[$set_comment->cid] = $set_comment;
      }
    }
    // Gather comments existing under AJAX.
    $exist_comments_table = !empty($form_state['values']['included_comments_table'])
      ? $form_state['values']['included_comments_table'] : array();
    foreach ($exist_comments_table as $existing_cid => $existing_comment) { 
      // If marked add it.
      if ($existing_comment['remove'] == 0) {
        $this_comment = (object) $existing_comment;
        $this_comment->cid = $existing_cid;
        $found_comments[$existing_cid] = $this_comment;
      }
      if ($existing_comment['remove'] == 1) {
        // Delete it as much as possible from the system.
        unset($form_state['values']['included_comments_table'][$existing_cid]);
        unset($found_comments[$existing_cid]);
        if (!empty($form['#node']->nid)) {
          _scene_record_delete_comment($form['#node']->nid, $existing_cid);
        }
      }
    }
    // Gather comments added via AJAX.
    $add_comments_table = !empty($form_state['values']['add_comments_table']) ? $form_state['values']['add_comments_table'] : array();
    // Reverse the order to match posting order.
    $add_comments_table = array_reverse($add_comments_table, TRUE);
    foreach ($add_comments_table as $add_comment => $added) {
      // If marked, and not already in the list, add it.
      if ($added && !in_array($add_comment, array_keys($found_comments))) {
        $this_comment->cid = $add_comment;
        $found_comments[$add_comment] = $this_comment;
      }
    }
    // One last organization of all of these by cid.
    ksort($found_comments);
    // Calculate the results for the set
    $found_comments = _scene_record_calculate_results($found_comments);
    // Add the comments.
    foreach ($found_comments as $cid => $scene_comment) {
      $comment = comment_load($cid);
      $comment_uri = comment_uri($comment);
      // Get the full text.
      $comment_text = '';
      if (!empty($comment->comment_body[$comment->language][0]['value'])) {
        $comment_text = check_markup($comment->comment_body[$comment->language][0]['value'], $comment->comment_body[$comment->language][0]['format']);
      }
      $comment_ooc = '';
      if (!empty($comment->field_ooc[$comment->language][0]['value'])) {
        $comment_ooc = check_markup($comment->field_ooc[$comment->language][0]['value'], $comment->field_ooc[$comment->language][0]['format']);
      }
      // Strip HTML - we can't use it in title overheads.
      $comment_text = strip_tags($comment_text);
      $comment_ooc = strip_tags($comment_ooc);
      $comment_title = check_plain($comment_text);
      if (!empty($comment_ooc)) {
        $comment_title .= "\n" . 'OOC: ' . check_plain($comment_ooc);
      }
      // Put together.
      $comment_display = '<a href="/' . $comment_uri['path'] . '#' . $comment_uri['options']['fragment'] . '" title="' . $comment_title . '">' .
        check_plain($comment->subject) . '</a>';
      // Add dice rolls if there are any.
      $dice_rolls = _dice_roller_get_roll($cid, 'c');
      $comment_display .= !empty($dice_rolls) ? theme('dice_roller_results', array('dice_rolls' => $dice_rolls)) : '';
      // Set in form.
      $comment_display = array(
        '#type' => 'item',
        '#markup' => $comment_display,
      );
      $results = array(
        '#type' => 'item',
        '#markup' => $scene_comment->results,
      );
      $remove = array(
        '#type' => 'checkbox',
        '#return_value' => 1,
        '#default_value' => 0,
      );
      $form['scene_record']['included_comments']['included_comments_table'][$cid] = array(
        'mights' => &$comment_display,
        'remove' => &$remove,
      );
      $form['scene_record']['included_comments']['included_comments_table']['#rows'][] = array(
        'class' => array('draggable'),
        'data' => array(
          array('data' => &$comment_display),
          array('data' => &$results),
          array('data' => &$remove),
        )
      );
      unset($comment_display);
      unset($results);
      unset($remove);
    }
    // Add calculate button.
    $form['scene_record']['included_comments']['recalculate'] = array(
      '#type' => 'button',
      '#value' => t('Calculate KXP'),
      '#limit_validation_errors' => array(array('included_comments_table')),
      // DOUBLE ARRAY. Because drupal docs suck.
      '#ajax' => array(
        'callback' => '_scene_record_ajax_add_comments',
        'wrapper' => 'scene-record-included-comments-table',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );
    // Hide the field creation history elements. We don't want users meddling with those.
    $form['field_scene']['#access'] = FALSE;
  }
}

/**
 * AJAX function, callback for load comments after room selected.
 */
function _scene_record_ajax_load_room_comments($form, $form_state) {
  return $form['scene_record']['add_comments']['add_comments_table'];
}

/**
 * AJAX function, callback for load comments after room selected.
 */
function _scene_record_ajax_add_comments($form, $form_state) {
  return !empty($form['scene_record']['included_comments']['included_comments_table']) ?
    $form['scene_record']['included_comments']['included_comments_table'] : '';
}

/**
 * Autocomplete function, callback for room look up.
 */
function _scene_record_autocomplete_room($string = '') {
  $matches = array();
  $room_type = variable_get('scene_record_room_type', '');
  if (!empty($string) && !empty($room_type)) {
    $results = db_query('SELECT n.nid, n.title FROM {node} n ' .
      'WHERE n.type LIKE :type ' .
      'AND n.title LIKE :title',
      array(':type' => $room_type, ':title' => '%' . $string . '%'));
    foreach ($results as $result) {
      $label = $result->title . ' [nid:' . $result->nid . ']';
      $matches[ check_plain($label) ] = check_plain($label);
    }
  }
  drupal_json_output($matches);
}

/**
 * Implementation of admin settings form.
 */
function _scene_record_admin_settings($form, &$form_state) {
  // Setting for workflow to drop the NPCs into on being claimed.
  $content_types = node_type_get_types();
  $types = array();
  foreach ($content_types as $type_id => $content_type) {
    $types[$type_id] = $content_type->name;
  }
  $form['scene_record_scene_type'] = array(
    '#title' => t('Scene content type'),
    '#description' => t('Content type for scenes.'),
    '#type' => 'select',
    '#options' => $types,
    '#default_value' => variable_get('scene_record_scene_type', ''),
  );
  $form['scene_record_room_type'] = array(
    '#title' => t('Room content type'),
    '#description' => t('Content type for rooms.'),
    '#type' => 'select',
    '#options' => $types,
    '#default_value' => variable_get('scene_record_room_type', ''),
  );
  $form['scene_record_num_posts'] = array(
    '#title' => t('Number of posts'),
    '#description' => t('Number of posts to display in interface.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('scene_record_num_posts', 50),
  );
  return system_settings_form($form);
}

/**
 * Helper function, given a set of partial or full comments, calculate results.
 */
function _scene_record_calculate_results($found_comments) {
  $total_kxp = 0;
  $character_kxp = array();
  $kxp_ratio = variable_get('vaxia_kxp_ratio', 70);
  foreach ($found_comments as $cid => $scene_comment) {
    $message_items = array();
    // Set defaults if not already set.
    $comment = comment_load($cid);
    $kxp = _vaxia_figure_kxp($comment->comment_body[$comment->language][0]['value']);
    $total_kxp = $total_kxp + $kxp;
    // Figure out how much overall XP for this scene.
    $total_xp = 0;
    if ($total_kxp >= $kxp_ratio) {
      $total_xp = floor($total_kxp / $kxp_ratio);
    }
    $character = !empty($comment->field_comment_character[$comment->language][0]['nid']) ?
      node_load($comment->field_comment_character[$comment->language][0]['nid']) : '';
    if (!empty($character)) {
      $character_kxp[$character->title] = isset($character_kxp[$character->title])
        ? $character_kxp[$character->title] + $kxp : $kxp;
    }
    // Set the overall post results.
    $message_items[] = t('KXP: :kxp', array(':kxp' => $kxp));
    $message_items[] = t('Total KXP: :total_kxp', array(':total_kxp' => $total_kxp));
    $message_items[] = t('Total XP: :total_xp', array(':total_xp' => $total_xp));
    // Set the results per character.
    foreach ($character_kxp as $name => $total_char_kxp) {
      // Figure out how much overall XP for this scene.
      $total_xp = 0;
      if ($total_char_kxp >= $kxp_ratio) {
        $total_xp = floor($total_char_kxp / $kxp_ratio);
      }
      $message_items[] = t('Total :name KXP: :total_char_kxp', array(':name' => $name, ':total_char_kxp' => $total_char_kxp));
      $message_items[] = t('Total :name XP: :total_xp', array(':name' => $name, ':total_xp' => $total_xp));
    }
    $message = theme('item_list', array('items' => $message_items));
    $scene_comment->results = $message;
  }
  return $found_comments;
}

/**
 * Helper function, given a string retrieve any nid in the format [nid:XXX].
 * Or look for the node by title.
 */
function _scene_record_autocomplete_get_nid($room_selected) {
  $result = preg_match('/\[nid:([0-9]+)\]$/', $room_selected, $matches);
  if ($result > 0) {
    $nid = $matches[$result];
    $node = node_load($nid);
    if (empty($node)) {
      $nodes = node_load_multiple(array(), array('title' => $room_selected));
      foreach ($nodes as $nid => $this_node) {
        $node = $this_node;
      }
    }
    $room_type = variable_get('scene_record_room_type', '');
    if (!empty($node) && $node->type == $room_type && $node->status == 1) {
      return $node->nid;
    }
  }
  return FALSE;
}

/**
 * DB function, get comments per room.
 */
function _scene_record_get_comments_by_room($nid) {
  $post_limit = variable_get('scene_record_num_posts', 50);
  $results = db_query('SELECT * FROM {comment} ' .
    'WHERE nid = :nid ' .
    'ORDER BY created DESC LIMIT 0, ' . $post_limit,
    array(':nid' => $nid))->fetchAll();
  return $results;
}

/**
 * DB function, get comments by nid.
 */
function _scene_record_get_comments($nid) {
  $results = db_query('SELECT * FROM {scene_record_comments} ' .
    'WHERE nid = :nid ' .
    'ORDER BY cid ASC',
    array(':nid' => $nid))->fetchAll();
  return $results;
}

/**
 * DB function, delete comment by nid.
 */
function _scene_record_delete_comments($nid) {
  db_query('DELETE FROM {scene_record_comments} ' .
    'WHERE nid = :nid',
    array(':nid' => $nid));
}

/**
 * CRUD function, get comment by nid, cid.
 */
function _scene_record_get_comment($nid, $cid) {
  $results = db_query('SELECT * FROM {scene_record_comments} ' .
    'WHERE nid = :nid AND cid = :cid',
    array(':nid' => $nid, ':cid' => $cid))->fetchAll();
  return $results;
}

/**
 * CRUD function, get comments by nid.
 */
function _scene_record_insert_comment($data) {
  $data = (array) $data;
  $result = _scene_record_get_comment($data['nid'], $data['cid']);
  if (!empty($result)) {
    _scene_record_update_comment($data);
  }
  drupal_write_record('scene_record_comments', $data);
}

/**
 * CRUD function, get comments by nid.
 */
function _scene_record_update_comment($data) {
  $data = (array) $data;
  $result = _scene_record_get_comment($data['nid'], $data['cid']);
  if (empty($result)) {
    _scene_record_insert_comment($data);
  }
  drupal_write_record('scene_record_comments', $data, array('nid', 'cid'));
}

/**
 * CRUD function, get comment by nid, cid.
 */
function _scene_record_delete_comment($nid, $cid) {
  db_query('DELETE FROM {scene_record_comments} ' .
    'WHERE nid = :nid AND cid = :cid',
    array(':nid' => $nid, ':cid' => $cid));
}