<?php
/**
 * @file
 * Code for the Proposals feature.
 */

include_once 'proposal.features.inc';

/**
 * Implements hook_permission().
 */
function proposal_permission() {
  return array(
    'vote on proposal'=> array(
      'title' => t('vote on proposal'),
      'description' => t('Votes on proposals.'),
    ),
    'administer proposal'=> array(
      'title' => t('administer proposal'),
      'description' => t('Administer proposal.'),
    ),
  );
}

/**
 * Implements hook_rules_event_info().
 */
function proposal_rules_event_info() {
  $items = array(
    'open_proposal' => array(
      'label' => t('Proposal open'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Proposal'),
        ),
      ),
    ),
    'close_proposal' => array(
      'label' => t('Proposal close'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Proposal'),
        ),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_cron().
 */
function proposal_cron() {
  _proposal_cron_proposal();
}

/**
 * Cron worker.
 */
function _proposal_cron_proposal() {
  $last_run = variable_get('proposal_cron', 0);
  $yesterday = strtotime('-1 day');
  if ($last_run < $yesterday) {
    $today = date('m/d/Y');
    $today = strtotime($today . ' 00:00:01'); // We always want to plan to run just after midnight.
    variable_set('proposal_cron', $today);
    // Close the proposals.
    proposal_close_in_timeframe();
  }
}

/**
 * Implements hook_menu().
 */
function proposal_menu() {
  $items['admin/vaxia/proposal'] = array(
    'title' => 'Proposal system',
    'description' => 'Site voting and administrative proposals.',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer proposal'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('proposal_admin_form'),
  );
  return $items;
}

/**
 * Menu callback, administration form.
 */
function proposal_admin_form($form, &$form_state) {
  $form = array();
  $form['proposal_open_timeframe'] = array(
    '#title' => t('Open timeframe'),
    '#description' => t('Timeframe to keep proposals open for. Use the same strings as date().'),
    '#type' => 'textfield',
    '#default_value' => variable_get('proposal_open_timeframe', '2 weeks'),
  );
  $form['proposal_voter_timeframe'] = array(
    '#title' => t('Voter timeframe'),
    '#description' => t('Timeframe for determining user activity as a voter. Use the same strings as date().'),
    '#type' => 'textfield',
    '#default_value' => variable_get('proposal_voter_timeframe', '6 months'),
  );
  return system_settings_form($form);
}

/**
 * Implements hook_menu_alter().
 */
function proposal_menu_alter(&$items) {
  // Remove all the paths people don't need.
  $items['node/%webform_menu/webform-results']['access callback'] = '_proposal_webform_results_access';
  $items['node/%webform_menu/webform/emails']['access callback'] = '_proposal_webform_email_access';
  $items['node/%webform_menu/webform/emails/%webform_menu_email']['access callback'] = '_proposal_webform_email_access';
  $items['node/%webform_menu/webform/emails/%webform_menu_email/delete']['access callback'] = '_proposal_webform_email_access'; 
  // That goes for the owner as well.
  $items['node/%webform_menu/webform-results']['access callback'] = '_proposal_webform_results_access';
}

/**
 * Menu access call for result paths().
 */
function _proposal_webform_results_access($node) {
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return webform_results_access($node); // Use defaults.
  }
  // Allow administrators at all times
  if (user_access('administer proposal')) {
    return user_access('administer proposal');
  }
  // Only show for a FINISHED contest. We do NOT need people vote stacking cause they know results.
  if ($node->webform['status'] == FALSE) {
    return webform_results_access($node);
  }
  return FALSE;
}

/**
 * Menu access call for email paths().
 */
function _proposal_webform_email_access($op, $node) {
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return node_access($op, $node); // Use defaults.
  }
  return FALSE;
}

/**
 * Implements hook_webform_submission_access().
 */
function proposal_webform_submission_access($node, $submission, $op = 'view', $account = NULL) {
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return FALSE; // Use defaults.
  }
  // If the submission is open and we're just listing it.
  if (isset($node->webform['status']) && $node->webform['status'] == TRUE && $op == 'list') {
    return TRUE;
  }
  // If the user looking is the owner, allow him to list, edit, delete, and view his submission.
  if (isset($node->webform['status']) && $node->webform['status'] == TRUE && $submission->uid == $account->uid) {
    return TRUE;
  }
  return FALSE; // Use defaults.
}

/**
 * Implements hook_theme_registry_alter().
 * Remove the exposure of sensitive material from the user facing interface.
 */
function proposal_theme_registry_alter(&$theme_registry) {
  $theme_registry['webform_token_help']['theme path'] = drupal_get_path('module', 'proposal');
  $theme_registry['webform_token_help']['function'] = 'proposal_webform_token_help';
  $theme_registry['webform_results_table']['theme path'] = drupal_get_path('module', 'proposal');
  $theme_registry['webform_results_table']['function'] = 'proposal_webform_results_table';
  $theme_registry['webform_results_analysis']['theme path'] = drupal_get_path('module', 'proposal');
  $theme_registry['webform_results_analysis']['function'] = 'proposal_webform_results_analysis';
}

/**
 * Implements theme_webform_token_help().
 * Remove the exposure of sensitive material from the user facing interface.
 * It removes it for all webforms sadly, because there's no good way to tell it not to with the theme system.
 */
function proposal_webform_token_help($variables) {
  // Ok, let's try this another way.
  $current_path = current_path();
  if (strpos($current_path, 'webform/components') !== FALSE) {
    $node = node_load(arg(1));
    if ($node->type == 'proposal') {
      return ''; // Hide the tokens from view.
    }
  }
  // Otherwise we show as expected.
  $groups = $variables['groups'];
  $fieldset = array(
    '#title' => t('Token values'), 
    '#type' => 'fieldset', 
    '#collapsible' => TRUE, 
    '#collapsed' => TRUE, 
    '#attributes' => array('class' => array('collapsible', 'collapsed')),
  );
  $help = '<p>' . t('This field supports dynamic token values. Common values might be [current-user:mail] or [node:title].') . '</p>';
  if (!module_exists('token')) {
    $help .= '<p>' . t('A full listing of tokens may be listed here by installing the <a href="http://drupal.org/project/token">Token module</a>.') . '</p>';
  }
  $fieldset['help'] = array(
    '#markup' => $help,
  );
  $fieldset['token_tree'] = array(
    '#theme' => 'token_tree', 
    '#token_types' => array(), // No groups.
  );
  return render($fieldset);
}

/**
 * Implements theme_webform_results_table();
 */
function proposal_webform_results_table($variables) {
  $node = $variables['node'];
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return theme_webform_results_table($variables);
  }

  $output = '';
  // To sum up, get analysis of all submissions.
  $output .= webform_results_analysis($node);
  // Show the individual results.
  // On a proposal, override the display so we only see the things we should see.
  drupal_add_library('webform', 'admin');
  $components = $variables['components'];
  $submissions = $variables['submissions'];
  $total_count = $variables['total_count'];
  $pager_count = $variables['pager_count'];
  $header = array();
  $rows = array();
  $cell = array();
  // This header has to be generated seperately so we can add the SQL necessary.
  // to sort the results.
  $header = array(
    array(
      'data' => t('Submitted'),
      'field' => 'submitted',
    ),
  );
  // Generate a row for each submission.
  foreach ($submissions as $sid => $submission) {
    $cell[] = format_date($submission->submitted, 'short');
    $component_headers = array();
    // Generate a cell for each component.
    foreach ($node->webform['components'] as $component) {
      $data = isset($submission->data[$component['cid']]) ? $submission->data[$component['cid']] : NULL;
      $submission_output = webform_component_invoke($component['type'], 'table', $component, $data['value']);
      if ($submission_output !== NULL) {
        $component_headers[] = check_plain($component['name']);
        $cell[] = $submission_output;
      }
    }
    $rows[] = $cell;
    unset($cell);
  }
  if (!empty($component_headers)) {
    $header = array_merge($header, $component_headers);
  }
  if (count($rows) == 0) {
    $rows[] = array(array(
        'data' => t('There are no submissions for this form.'),
        'colspan' => count($header),
      ));
  }
  $output .= theme('webform_results_per_page', array('total_count' => $total_count, 'pager_count' => $pager_count));
  $output .= theme('table', array('caption' => '<h2>' . t('Detailed responses') . '</h2>', 'header' => $header, 'rows' => $rows,
    'attributes' => array('class' => array('webform-detailed-responses'))));
  return $output;
}

/**
 * Implements theme_webform_results_analysis().
 */
function proposal_webform_results_analysis($variables) {
  $node = $variables['node'];
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return theme_webform_results_analysis($variables);
  }
  $data = $variables['data'];
  $sids = $variables['sids'];
  $analysis_component = $variables['component'];
  $rows = array();
  $question_number = 0;
  $first = ' webform-results-question-first';
  $single = isset($analysis_component);
  $header = array(
    array(
      'data' => '&nbsp;',
      'colspan' => '11',
    ),
  );
  foreach ($data as $cid => $row_data) {
    $question_number++;
    if (is_array($row_data)) {
      $row = array();
      if (!$single) {
        $row['data'][] = array(
          'data' => '',
          'rowspan' => count($row_data) + 1,
          'valign' => 'top',
        );
        $row['data'][] = array(
          'data' => '<strong>' . check_plain($node->webform['components'][$cid]['name']) . '</strong>',
          'colspan' => '10',
        );
        $row['class'][] = 'webform-results-question' . $first;
         $first = '';
      }
      $rows = array_merge($rows, array_merge(array($row), $row_data));
    }
  }
  if (count($rows) == 0) {
    $rows[] = array(array(
        'data' => t('There are no submissions for this form. <a href="!url">View this form</a>.', array('!url' => url('node/' . $node->nid))),
        'colspan' => 20,
      ));
  }
  $output = '<div class="webform-results-analysis-help">' . t('Summary of responses reflects how many users selected a given value in the poll. ' .
    'In general, the larger the number the stronger the overall preference for that result. Text responses are briefly summarized but should be ' .
    'read individually.') .'</div>';
  $output .= theme('table', array('caption' => '<h2>' . t('Summary of responses') . '</h2>', 'header' => $header, 'rows' => $rows,
    'attributes' => array('class' => array('webform-results-analysis'))));
  return $output;
}

/**
 * Implements hook_node_delete().
 */
function proposal_node_delete($node) {
  // Delete an election associated with a proposal if we delete the node.
  if ($node->type == 'proposal') {
    proposal_clear_eligable($node->nid);
    // Clear out the disallowed roles option for this proposal
    $disallowed = variable_get('proposal_disallowed_roles', array());
    if (isset($disallowed[ $node->nid ])) {
      unset($disallowed[ $node->nid ]);
    }
    variable_set('proposal_disallowed_roles', $disallowed);
  }
}

/**
 * Implements hook_node_view().
 */
function proposal_node_view($node, $view_mode, $langcode) {

  // Only override the displays for proposals.
  if ($node->type == 'proposal') {
    module_load_include('inc', 'webform', 'includes/webform.report');
    // Get 2 weeks in the future timestamp.
    $timeframe = variable_get('proposal_open_timeframe', '2 weeks');
    $date = strtotime($timeframe, $node->changed); // Two weeks from now.
    $date = date('l, F j, Y', $date);
    // Show messages.
    if ($view_mode == 'full') {
      if ($node->webform['status'] == TRUE) {
        drupal_set_message(t('This proposal will stay open for two weeks since it was last updated. It is set to close on @date.',
          array('@date' => $date)));
      }
      else {
        drupal_set_message(t('This proposal is closed.'));
      }
    }

    // Update content.
    $node->content['proposal_help'] = array(
      '#markup' => '<div class="proposal_help"></br></br>' . t('<b>Proposal help:</b></br>Proposals are meant to be a way to formally make a request ' .
      'for the input of site members. Forum threads and five-star ratings are not accurate enough for the big things. So here\'s how this works:</br> ' .
      '<ul> ' .
      '<li>If you change your mind after you vote, you will be able to go back in and delete or change your vote up until the proposal closes.</li> ' .
      '<li>The form will be open for %timeframe, after which it will automatically close.</li> ' .
      '<li>If the original poster edits it in that timespan the timer will re-set. This is to make sure everyone can get a chance to weigh in.</li> ' .
      '<li>Only users active when the proposal was created can vote on it. This is to avoid ballot stuffing.</li> ' .
      '<li>No one, not even the original poster will be able to see the names or IP addresses of the people do vote.</li> ' .
      '<li>After the two week window has passed, the proposal will close and results will be publicly availble in a tab on this page.</li> ' .
      '</ul></div>', array('%timeframe' => $timeframe)),
      '#weight' => 1000,
    );

    // Check how many people have voted that are allowed to vote.
    // Add that information to the display.
    $potential_voters = proposal_eligable_count($node->nid);
    $voted = webform_get_submission_count($node->nid);
    if ($potential_voters != 0) {
      $percent = number_format(($voted / $potential_voters) * 100);
      $active_voters = proposal_eligable_active_count($node->nid, $node->changed); // Within a window of two weeks active.
      $percent_active = number_format(($voted / $active_voters) * 100);
      $node->content['proposal_response'] = array(
        '#markup' => '<div class="proposal_response" style="margin:1em 0;">' . t('%voted out of %potential_voters potential voters (%percent %) responsed ' .
        'to this proposal. %voted2 out of %active_voters potential voters active on the site in the last week (%percent_active %) responded to this proposal.',
        array('%voted' => $voted, '%potential_voters' => $potential_voters, '%percent' => $percent,
          '%voted2' => $voted, '%active_voters' => $active_voters, '%percent_active' => $percent_active, )) . '</div>',
        '#weight' => 1001,
      );
    }
    else {
      $node->content['proposal_response'] = array(
        '#markup' => '<div class="proposal_response" style="margin:1em 0;">' . t('There are no potential voters for this proposal at this time.') . '</div>',
        '#weight' => 1001,
      );
    }

    // And if the vote has been closed - add that.
    if ($node->webform['status'] == FALSE && $voted == 0 ) {
      // If no one has voted yet, we can launch the proposal.
      global $user;
      if ( $node->uid == $user->uid || user_access('administer proposal')) {
        $node->content['proposal_launch'] = array(
          '#markup' => drupal_render(drupal_get_form('_proposal_launch_form', $node)),
          '#weight' => -1000,
        );
      }
      else {
        drupal_set_message(t('This proposal has not yet been opened. Please give them time to finish creating the proposal.'));
      }
    }

    // Show results if any.
    if ($node->webform['status'] == FALSE || user_access('administer proposal')) {
      $node->content['proposal_results'] = array(
        '#markup' => '<div class="proposal_result">' . webform_results_table($node) . '</div>',
        '#weight' => 1003,
      );
    }
  }

}

/**
 * Form callback to launch a proposal when ready.
 */
function _proposal_launch_form($form, &$form_state, $node) {
  $form['launch_help'] = array(
    '#markup' => '<div class="proposal_launch_help">' .
    t('When you are ready to make this proposal live so that others may vote on it, click this button.') . '</div>',
  );
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
  );
  $form['launch'] = array(
    '#type' => 'submit',
    '#value' => t('Click here to launch the proposal'),
  );
  return $form;
}

/**
 * Form callback to launch a proposal when ready.
 */
function _proposal_launch_form_submit($form, &$form_state) {
  $node = node_load($form_state['values']['nid']);
  $node->webform['status'] = TRUE;
  node_save($node);
  drupal_set_message(t('This proposal has been opened for voting.'));
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function proposal_form_webform_components_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return; // Use defaults.
  }
  $form['help'] = array(
    '#markup' => '<style>.form-item-add-name{margin-left:30px;}</style>' .
      '<div class="webform_component_help">' .
      'Once you add a form piece to the form you can shuffle them around to display them in the order you want them to display in. ' .
      'Mandatory form components are questions that must be answered before a submission can be made. ' .
      'The pieces you can add are mostly self-explanatory but a few you may not be familiar with: </br></br>' .
      '* Fieldset: Just a display wrapper - a box - around the other form pieces. </br>' .
      '* Grid: A way to display a table of options beside a label. </br>' .
      '* Markup: Text to display - useful for help messages. </br>' .
      '* Text area: Multi-line area for entering text. </br>' .
      '* Text field: Single-line area for entering text. </br>' .
      '</br>' .
      'Once you have all the form pieces you want, in the order you want them, click "Save" to set the proposal active.' .
      '</div>',
    '#weight' => -40,
  );
  // Recreate the options array for the types of components we want to allow.
  $options = webform_component_options();
  unset($options['email']);
  unset($options['pagebreak']);
  $form['add']['type']['#options'] = $options;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function proposal_form_webform_component_edit_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return; // Use defaults.
  }
  $form['help'] = array(
    '#markup' => '<div class="webform_component_help">' .
      'Edit the individual pieces of your form here. A name is required, as is a form_key so that the form submission system can recognize the ' .
      'value later. Where you see the form ask for "Key-value pairs", the format is key|value - where the Key is stored in the database (no worries ' .
      'almost anything you pick is ok), and the Value is what is shown to the person selecting options on your form. </br></br>' .
      '</div>',
    '#weight' => -40,
  );
  // Remove private fields.
  unset($form['display']['private']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function proposal_form_proposal_node_form_alter(&$form, &$form_state, $form_id) {
  // Since this is specifically on the proposal node form, no need to bail out.
  // Insert our submit call before webforms call to make sure we complete properly.
  // Since webform doesn't allow us to mark the content type as a primary.
  $form['actions']['submit']['#submit'][] = '_proposal_form_proposal_node_form_submit';
}

/**
 * Form submit callback().
 */
function _proposal_form_proposal_node_form_submit($form, &$form_state) {
  // Get the node.
  $node = node_load($form_state['nid']);
  // If we're not looking at a proposal, bail out with the normal view.
  if ($node->type != 'proposal') {
    return; // Use defaults.
  }
  // Set up the webform defaults if node hasn't yet.
  if (!isset($node->webform)) {
    $node->webform = webform_node_defaults();
  }
  if ($node->webform == webform_node_defaults()) {
    // Insert the webform.
    $node->webform['nid'] = $node->nid;
    $node->webform['record_exists'] = (bool) drupal_write_record('webform', $node->webform);
    // Set the webform body
    $node->body[$entity_created->language][0]['value'] = $output;
    $node->webform['confirmation'] = t('Thank you for participating!');
    $node->webform['confirmation_format'] = 'plain_text';
    $node->webform['submit_limit'] = 1;
    // Set the per-role submission access control.
    // Automatically add voter since this system will add that role.
    $role = user_role_load_by_name('voter');
    if ($role) {
      $node->webform['roles'] = array($role->rid);
    }
    // Set the default users.
    _proposal_webform_set_users(array($role->rid), array(), $node->nid);
    // Set the status to OFF on new nodes.
    $node->webform['status'] = FALSE;
    // Save the node.
    node_save($node);
    if (function_exists('rules_invoke_event')) {
      $node = node_load($proposal->nid);
      rules_invoke_event('open_proposal', $node);
    }
  }
  drupal_set_message(t('The webform %title has been updated. Add new fields to your webform with the form below. ' .
    'When you are ready to open the proposal to voters go to the View tab and click the button to launch it.',
    array('%title' => $form_state['values']['title'])));
  $form_state['redirect'] = 'node/' . $form_state['nid'] . '/webform/components';
}

/**
 * Implements hook_form_alter().
 */
function proposal_form_alter(&$form, &$form_state, $form_id) {

  // If we're viewing a webform.
  // Why hook_form_alter and not hook_form_FORM_ID_alter? Because webform's form id varies: webform_client_form_NID.
  if (strstr($form_id, 'webform_client_form') !== FALSE) {
    $node = $form['#node'];
    // If we're not looking at a proposal, bail out with the normal view.
    if ($node->type != 'proposal') {
      return; // Use defaults.
    }
    // Only toss up the message if the form cares about the voter eligability AND it is open.
    if ($node->webform['status'] == TRUE) {
      global $user;
      // Voter eligability was determined when the proposal was created / last updated.
      // This list marked voters AT THE TIME - allowing us to use that master list for voting eligibilty.
      $eligable = proposal_is_eligable($node->nid, $user->uid);
      if (!$eligable) {
        drupal_set_message('You are not eligible to vote on this issue. Either you do not have the correct site permissions to vote, ' .
          'or you gained them after the proposal was opened for voting.', 'warning');
        $form['#disabled'] = TRUE;
      }
    }
  } // End alter of webform.

  // Edit the webform form for creators to limit to the right roles.
  if ($form_id == 'webform_configure_form' && $form['#node']->type == 'proposal') {
    $timeframe = variable_get('proposal_open_timeframe', '2 weeks');
    // Change the form around.
    // Admins can close it if the proposal was opened in error.
    if (!user_access('administer proposal')) {
      $form['submission']['status']['#disabled'] = TRUE;
      $form['submission']['status']['#description'] .= ' ' .
        t('This propsal will remain open for submission for %timeframe from the last time it was updated.', array('%timeframe' => $timeframe));
    }
    // Leave it to the machine to open and close the proposal. No early, no late.
    $form['submission']['redirection']['#access'] = FALSE;
    // This also removes the tokens from display to end user.
    // Only one per customer.
    $form['submission']['total_submit_limit']['#access'] = FALSE;
    $form['submission']['submit_limit']['#access'] = FALSE;
    $form['submission']['submit_limit']['enforce_limit']['#value'] = 'yes';
    $form['submission']['submit_limit']['enforce_limit']['#default_value'] = 'yes';
    $form['submission']['submit_limit']['submit_limit']['#value'] = 1;
    $form['submission']['submit_limit']['submit_limit']['#default_value'] = 1;
    // And only particular users, tweak the descriptions.
    $form['role_control']['#description'] = t('These permissions affect which roles can submit this webform. ' .
      'It does not prevent access to the webform page to view results.');
    // Voters role was automatically set during node creation.
    $voter_timeframe = variable_get('proposal_voter_timeframe', '6 months');
    $form['role_control']['roles']['#description'] = t('Voters are users who have posted on the site in the last %voter_timeframe.',
	  array('%voter_timeframe' => $voter_timeframe));
	// Clear out roles not marked for voting purposes to reduse UI confusion.
    $allowed_roles = user_roles(FALSE, 'vote on proposal');
    foreach ($form['role_control']['roles']['#options'] as $rid => $role_name) {
      if (!in_array($role_name, $allowed_roles)) {
        unset($form['role_control']['roles']['#options'][$rid]);
      }
    }
    // Now, add a role_disallowed setup.
    $form['role_control']['disallowed_fieldset'] = array(
      '#type' => 'fieldset',
      '#title' => t('Disallowed roles'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['role_control']['disallowed_fieldset']['disallowed_roles'] = $form['role_control']['roles'];
    $form['role_control']['disallowed_fieldset']['disallowed_roles']['#title'] = t('Roles that CANNOT submit this webform');
    $form['role_control']['disallowed_fieldset']['disallowed_roles']['#description'] = t('Sometimes a proposal needs to disallow a specific set of users from ' .
      'voting due to conflict of interest. Even if a user is in a role that can vote normally, if they have one of these roles they are ' .
      'barred from voting. Leave the roles listed here unchecked if you do not want to bar voters.');
    unset($form['role_control']['disallowed_fieldset']['disallowed_roles']['#default_value']);
    $disallowed = variable_get('proposal_disallowed_roles', array());
    if (!empty($disallowed[$form['#node']->nid])) {
      $form['role_control']['disallowed_fieldset']['disallowed_roles']['#default_value'] = $disallowed[$form['#node']->nid];
    }
    // And no advanced formats.
    $form['advanced']['#access'] = FALSE;
    // Add submit handler.
    $form['#submit'][] = '_proposal_webform_configure_form_submit';
  } // End alter of webform form settings.

  return $form;
}

/**
 * Submit handler for voters for this proposal.
 */
function _proposal_webform_configure_form_submit($form, &$form_state) {
  $eligable = array_values($form_state['values']['roles']);
  $not_eligable = array_values($form_state['values']['disallowed_roles']);
  // Save disallowed roles for this node.
  $disallowed = variable_get('proposal_disallowed_roles', array());
  $disallowed[ $form_state['values']['nid'] ] = $not_eligable;
  variable_set('proposal_disallowed_roles', $disallowed);
  _proposal_webform_set_users($eligable, $not_eligable, $form_state['values']['nid']);
}

/**
 * Helper function, set allowed / disallowed users for a proposal.
 */
function _proposal_webform_set_users($eligable, $not_eligable, $nid) {
  // Gather users to set.
  $users = array();
  // Load all users in eligable roles.
  foreach ($eligable as $rid) {
    $role_users = db_query('SELECT uid FROM {users_roles} WHERE rid = :rid', array(':rid' => $rid));
    foreach ($role_users as $role_user) {
      $users[$role_user->uid] = $role_user->uid;
    }
  }
  // Then filter them by in-eligable roles.
  foreach ($not_eligable as $rid) {
    $role_users = db_query('SELECT uid FROM {users_roles} WHERE rid = :rid', array(':rid' => $rid));
    foreach ($role_users as $role_user) {
      unset($users[$role_user->uid]);
    }
  }
  // Clear the old voters.
  proposal_clear_eligable($nid);
  // And add them to the master list for this node.
  foreach ($users as $user) {
    $data['uid'] = $user;
    $data['nid'] = $nid;
    proposal_mark_eligable($data);
  }
}

/**
 * CRUD function. Set eligable voters for a node.
 */
function proposal_mark_eligable($data) {
  $data = (array) $data;
  if (empty($data['nid']) || empty($data['uid'])) {
    return FALSE;
  }
  // Mark the eligable voter for this node.
  drupal_write_record('proposal_eligable_users', $data);
  return (object) $data;
}

/**
 * DB function. Delete eligable voters for the node.
 */
function proposal_clear_eligable($nid) {
  if (empty($nid)) {
    return FALSE;
  }
  db_query('DELETE FROM {proposal_eligable_users} WHERE nid = :nid',
    array(':nid' => $nid));
}

/**
 * DB function. Count eligable voters.
 */
function proposal_eligable_count($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  $eligable = db_query('SELECT COUNT(uid) AS eligable FROM {proposal_eligable_users} ' .
    'WHERE nid = :nid ',
    array(':nid' => $nid))->fetchField();
  if (empty($eligable)) {
    return 0; // Bail if error.
  }
  return $eligable;
}

/**
 * DB function. Count eligable voters.
 */
function proposal_eligable_active_count($nid, $from_time) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  $time = strtotime('-1 weeks', $from_time);
  // Check if they created a comment in the timeframe.
  // Why comments? Cause creating a character and vanishing from the site
  // happens, and we want to see gut-check-level active people. That means
  // we need people who are interacting - talking in comments. 
  $eligable = db_query('SELECT COUNT(u.uid) AS eligable FROM {proposal_eligable_users} u ' .
    'WHERE u.nid = :nid ' .
    'AND u.uid IN ( ' .
      'SELECT uid FROM comment WHERE changed > :time ' .
    ')',
    array(':nid' => $nid, ':time' => $time))->fetchField();
  if (empty($eligable)) {
    return 0; // Bail if error.
  }
  return $eligable;
}

/**
 * DB function. Get voter eligability.
 */
function proposal_is_eligable($nid, $uid) {
  if (empty($nid) || empty($uid)) {
    return FALSE; // Bail if error.
  }
  $eligable = db_query('SELECT COUNT(uid) AS count_uid FROM {proposal_eligable_users} ' .
    'WHERE uid = :uid ' .
    'AND nid = :nid ',
    array(':uid' => $uid, ':nid' => $nid))->fetchField();
  if (empty($eligable)) {
    return FALSE; // Bail if error.
  }
  return TRUE;
}

/**
 * Helper for rules. Check if user was a voter before the proposal was made.
 */
function proposal_check_posted_in_last_timeframe($uid) {
  $count = 0;
  $time = variable_get('proposal_voter_timeframe', '6 months') . ' ago';
  $results = db_query('SELECT COUNT(nid) AS count FROM {node} ' .
    'WHERE uid = :uid ' .
    'AND created > :time',
    array(':uid' => $uid, ':time' => $time));
  foreach ($results as $result) {
    $count += $result->count;
  }
  $results = db_query('SELECT COUNT(cid) AS count FROM comment} ' .
    'WHERE uid = :uid ' .
    'AND created > :time',
    array(':uid' => $uid, ':time' => $time));
  foreach ($results as $result) {
    $count += $result->count;
  }
  // User IS a voting user.
  if ($count > 0) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper for rules. Close proposals that are due to be closed.
 */
function proposal_close_in_timeframe() {
  $timeframe = variable_get('proposal_open_timeframe', '2 weeks') . ' ago';
  $timeframe = strtotime($timeframe); // 2 weeks ago based on now.
  $timeframe = strtotime('+1 day', $timeframe); // Add a day so we pick up the correct 'midnight'.
  $timeframe = strtotime('midnight', $timeframe); // 2 weeks ago just before midnight.
  // And get the correct timeframe assuming a start time of 2 weeks ago.
  $proposals = db_query('SELECT n.nid FROM {node} n ' .
    'LEFT JOIN webform w ON n.nid = w.nid ' .
    'WHERE n.type = \'proposal\' ' .
    'AND n.changed <= :timeframe ' .
    'AND n.status = 1 ' .
    'AND w.status = 1 ',
    array(':timeframe' => $timeframe));
  // Trigger event.
  foreach ($proposals as $proposal) {
    if (function_exists('rules_invoke_event')) {
      $node = node_load($proposal->nid);
      // Clear out the disallowed roles option for this proposal
      $disallowed = variable_get('proposal_disallowed_roles', array());
      if (isset($disallowed[ $node->nid ])) {
        unset($disallowed[ $node->nid ]);
      }
      variable_set('proposal_disallowed_roles', $disallowed);
      // Call the rules.
      rules_invoke_event('close_proposal', $node);
    }
  }
}

/**
 * Helper function for views.
 */
function _proposal_closes_on_value($created) {
  $timeframe = variable_get('proposal_open_timeframe', '2 weeks');
  $date = strtotime($timeframe, $created); // Two weeks from now.
  $date = date('l, F j, Y', $date);
  return $date;
}