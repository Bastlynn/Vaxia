<?php
/**
 * @file
 * Code for the Vaxia NPCs feature.
 */

include_once 'npcs.features.inc';

/**
 * Implements hook_permission().
 */
function npcs_permission() {
  return array(
    'claim NPC'=> array(
      'title' => t('claim NPC'),
      'description' => t('Claim NPC from toybox'),
    ),
    'administer NPC handler'=> array(
      'title' => t('administer NPC handler'),
      'description' => t('Administrate NPC handler'),
    ),
    'create NPCs' => array(
      'title' => t('create NPCs'),
      'description' => t('Create NPCs for posting.'),
    ),
    'create open NPCs' => array(
      'title' => t('create open NPCs'),
      'description' => t('Create open NPCs for posting.'),
    ),
    'use NPCs' => array(
      'title' => t('use NPCs'),
      'description' => t('Use NPCs for posting.'),
    ),
    'keep NPCs' => array(
      'title' => t('keep NPCs'),
      'description' => t('Keep NPCs from being picked up by others.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function npcs_menu() {
  $items['admin/vaxia/npcs'] = array(
    'title' => 'NPC handling',
    'description' => 'Configure NPC handling',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_npcs_admin_settings'),
    'access arguments' => array('administer NPC handler'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
* Implements hook_cron_queue_info().
*/
function npcs_cron_queue_info() {
  $queues = array();
  $queues['vaxiaNPCReturnQueue'] = array(
    'worker callback' => '_npcs_return_npcs',
    'time' => 60,
  );
  return $queues;
}

/**
 * Implements hook_cron().
 */
function npcs_cron() {
  $last_run = variable_get('npcs_cron', 0);
  $yesterday = strtotime('-1 day');
  if ($last_run < $yesterday) {
    $queue = DrupalQueue::get('vaxiaNPCReturnQueue');
    $last_run = variable_set('npcs_cron', strtotime('now'));
    // On cron. Go through ALL NPC sheets.
    // Using this query to make sure we don't load anything we really don't need to.
    $npcs = db_query('SELECT npc.entity_id FROM {field_data_field_is_npc} npc ' . // Where an NPC
      'LEFT JOIN {node} n ON npc.entity_id = n.nid AND npc.revision_id = n.vid ' .
      'WHERE n.status = 1 ' . // Active node
      'AND npc.field_is_npc_value = 1 ' . // Is an NPC
      'UNION ' . // Merge two sets
      'SELECT onpc.entity_id FROM {field_data_field_is_open_npc} onpc ' . // Where an open NPC
      'LEFT JOIN {node} n2 ON onpc.entity_id = n2.nid AND onpc.revision_id = n2.vid ' .
      'WHERE n2.status = 1 ' . // Active node
      'AND onpc.field_is_open_npc_value = 1 ' // Is an open NPC
    );
    foreach ($npcs as $npc) {
      $remove = TRUE;
      // Determine what the latest post (if there was one) with this character was.
      $comment_times = db_query('SELECT MAX(c.created) AS comment_time FROM {comment} c ' .
        'LEFT JOIN {field_data_field_comment_character} npc ON c.cid = npc.entity_id ' .
        'WHERE npc.field_comment_character_nid = :nid ',
        array(':nid' => $npc->entity_id)
      );
      $timeout = strtotime(variable_get('npcs_claim_timeout', '6 months') . ' ago');
      foreach ($comment_times as $comment_time) {
        if ($timeout < $comment_time->comment_time) {
          $remove = FALSE;
        }
      }
      // Remove if we still want to remove it.
      if ($remove) {
        $item = array(
          'nid' => $npc->entity_id
        );
        $queue->createItem($item);
      }
    }
  }
}

/**
 * Callback function, put NPCs away after long disuse.
 */
function _npcs_return_npcs($node_data) {
  $node = node_load($node_data['nid']);
  if (_character_sheet_is_enabled($node)  && _character_sheet_is_playable($node) && _npcs_is_an_npc($node)) {
    if (!_npcs_can_be_claimed($node) && !_npcs_recently_approved($node)) {
      $workflow = variable_get('npcs_return_workflow', '');
      workflow_execute_transition($node, $workflow, t('NPC has been returned to the wiki by timeout.'), TRUE);
      if (function_exists('rules_invoke_event')) {
        $user = user_load(1);
        rules_invoke_event('npcs_return', $user, $node);
      }
    }
  }
}

/**
 * Implements hook_rules_event_info().
 */
function npcs_rules_event_info() {
  $items = array(
    'npcs_claim' => array(
      'label' => t('NPC claimed'),
      'group' => t('Vaxia'),
      'variables' => array(
        'user' => array(
            'type' => 'user',
            'label' => t('NPC user'),
        ),
        'node' => array(
            'type' => 'node',
            'label' => t('NPC'),
        ),
      ),
    ),
    'npcs_request' => array(
      'label' => t('NPC requested'),
      'group' => t('Vaxia'),
      'variables' => array(
        'user' => array(
            'type' => 'user',
            'label' => t('NPC user'),
        ),
        'node' => array(
            'type' => 'node',
            'label' => t('NPC'),
        ),
      ),
    ),
    'npcs_return' => array(
      'label' => t('NPC returns'),
      'group' => t('Vaxia'),
      'variables' => array(
        'user' => array(
            'type' => 'user',
            'label' => t('NPC user'),
        ),
        'node' => array(
            'type' => 'node',
            'label' => t('NPC'),
        ),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function npcs_form_character_sheet_node_form_alter(&$form, &$form_state, $form_id) {
  $node = isset($form['#node']) ? $form['#node'] : '';
  if (_character_sheet_is_enabled($node) && _character_sheet_is_playable($node)) {
    if (_npcs_is_an_open_npc($node) || _npcs_is_an_npc($node)) {
      $allowed_edit = array('field_age_app', 'field_background', 'field_personality', 'field_description', 'field_occupation',
        'field_last_name', 'field_titles', 'field_is_open_npc', 'field_race', 'field_sex', 'field_age_real',
        'field_character_owner', 'field_sh_notes', 'field_sh_private_notes', 'field_player_notes');
      foreach (element_children($form) as $child) {
        if ((strpos($child, 'field_') === 0 || $child == 'title') && !in_array($child, $allowed_edit)) {
          $form[$child]['#disabled'] = TRUE;
        }
      }
      drupal_set_message('You are attempting to edit an NPC that has already been approved for play. NPC numbers cannot be further edited ' .
        'after approval. Please revert this NPC to draft, and take it through the approval process again if you need to update numbers.');
    }
  }
  $form['#after_build'][] = '_npcs_node_form_workflow_after_build';
}

/**
 * Implements form after build.
 */
function _npcs_node_form_workflow_after_build($form, $form_state) {
  global $user;
  $node = isset($form['#node']) ? $form['#node'] : '';
  if (!empty($form['#wf']->name) && !empty($node) && $user->uid == $node->uid && $node->type == 'character_sheet') {
    $workflow_name = $form['#wf']->name;
    $options = $form['workflow'][$workflow_name]['#options'];
    $index = array_search('approved', $options);
    if ($index !== FALSE && $index != $node->workflow) {
      drupal_set_message(t('You own this NPC, you cannot set it to approved. Currently: ' . $node->workflow_state_name));
      unset($options[$index]);
      unset($form['workflow'][$workflow_name][$index]);
      $form['workflow'][$workflow_name]['#options'] = $options;
      $form['workflow'][$workflow_name]['#default_value'] = $node->workflow;
    }
  }
  return $form;
}

/*
 * Implements hook_node_view().
 */
function npcs_node_view($node, $view_mode, $langcode) {
  // If node is a character sheet, marked as an NPC.
  if (user_access('claim NPC') && _character_sheet_is_enabled($node) && _npcs_is_an_npc($node)) {
    global $user;
    // If workflow is in the claimable mode and this is open or owned NPC, add button.
    if (_npcs_can_be_claimed($node) && ($node->uid == $user->uid || _npcs_is_an_open_npc($node) || !_npcs_owner_is_sh($node))) {
      $node->content['npcs_form'] = drupal_get_form('_npcs_claim_form', $node);
      $node->content['npcs_form']['#weight'] = -100;
    }
    // If workflow is in the claimable mode and this is not open anod no owned NPC, add button.
    if (_npcs_can_be_claimed($node) && ($node->uid != $user->uid && !_npcs_is_an_open_npc($node) && _npcs_owner_is_sh($node))) {
      $node->content['npcs_form'] = drupal_get_form('_npcs_request_form', $node);
      $node->content['npcs_form']['#weight'] = -100;
    }
    // Else, is in active use. If the viewer is the owner give the button to return.
    if (!_npcs_can_be_claimed($node) && ($node->uid == $user->uid || _npcs_is_an_open_npc($node))) {
      $node->content['npcs_form'] = drupal_get_form('_npcs_return_form', $node);
      $node->content['npcs_form']['#weight'] = -100;
    }
  }
}

/**
 * Implementation of admin settings form.
 */
function _npcs_claim_form($form, &$form_state, $node) {
  $form = array();
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
  );
  $form['vaxia_npc_claim'] = array(
    '#type' => 'submit',
    '#value' => t('Claim NPC'),
  );
  return $form;
}

/*
 * Form callback submission for _npcs_claim_form.
 */
function _npcs_claim_form_submit($form, $form_state) {
  $workflow = variable_get('npcs_claim_workflow', '');
  $node = node_load($form_state['values']['nid']);
  // If the current owner is no longer an SH, then the logged in user gets to claim ownership.
  if (!_npcs_owner_is_sh($node)) {
    global $user;
    $node->uid = $user->uid;
    node_save($node);
  }
  // Make the transition.
  workflow_execute_transition($node, $workflow, t('NPC has been claimed from the wiki.'), TRUE);
  $time = variable_get('npcs_claim_timeout', '6 months');
  drupal_set_message(t('You have claimed this NPC for use in sessions. A few things to remember: This NPC will need to go through ' .
    'approval to make sure it follows current site policies. Once you are done using the NPC, please remember to return the NPC to ' .
    'the wiki for long term storage. If you don\'t post with the NPC for at least ' . $time . ' it will be automatically returned.'));
  if (function_exists('rules_invoke_event')) {
    global $user;
    rules_invoke_event('npcs_claim', $user, $node);
  }
}

/**
 * Implementation of request form.
 */
function _npcs_request_form($form, &$form_state, $node) {
  $form = array();
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
  );
  $form['vaxia_npc_request'] = array(
    '#type' => 'submit',
    '#value' => t('Request NPC'),
  );
  return $form;
}

/*
 * Form callback submission for _npcs_request_form.
 */
function _npcs_request_form_submit($form, $form_state) {
  $node = node_load($form_state['values']['nid']);
  $time = variable_get('npcs_request_timeout', '6 months');
  drupal_set_message(t('You have requested this NPC for use in sessions. Because it is not an open NPC, the current owner needs to ' . 
    'coordinate use with you to avoid story conflicts with ongoing or future sagas. They have been sent an email to get that conversation ' .
    'started, but you may want to follow up with them directly as well.'));
  if (function_exists('rules_invoke_event')) {
    global $user;
    rules_invoke_event('npcs_request', $user, $node);
  }
}

/**
 * Implementation of return form.
 */
function _npcs_return_form($form, &$form_state, $node) {
  $form = array();
  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $node->nid,
  );
  $form['vaxia_npc_return'] = array(
    '#type' => 'submit',
    '#value' => t('Return NPC to wiki'),
  );
  return $form;
}

/*
 * Form callback submission for _npcs_return_form.
 */
function _npcs_return_form_submit($form, $form_state) {
  $workflow = variable_get('npcs_return_workflow', '');
  $node = node_load($form_state['values']['nid']);
  workflow_execute_transition($node, $workflow, t('NPC has been returned to the wiki.'), TRUE);
  drupal_set_message(t('Thank you for returning this NPC to the wiki. This allows us to keep a clean inventory of NPCs active in the system for ' .
    'regular use, and keep our NPCs consistant over time with existing site policy.'));
  if (function_exists('rules_invoke_event')) {
    global $user;
    rules_invoke_event('npcs_return', $user, $node);
  }
}

/**
 * Implementation of admin settings form.
 */
function _npcs_admin_settings($form, &$form_state) {
  // Setting for workflow to drop the NPCs into on being claimed.
  $workflow_options = array();
  $workflows = workflow_get_workflows();
  foreach ($workflows as $workflow) {
    $states = workflow_get_workflow_states_by_wid($workflow->wid);
    foreach ($states as $state) {
      $workflow_options[$state->sid] = $workflow->name . ':' . $state->state;
    }
  }
  $form['npcs_claim_workflow'] = array(
    '#title' => 'Claim workflow',
    '#description' => 'Workflow state for NPCs who are being claimed.',
    '#type' => 'select',
    '#options' => $workflow_options,
    '#default_value' => variable_get('npcs_claim_workflow', ''),
  );
  $form['npcs_return_workflow'] = array(
    '#title' => 'Return workflow',
    '#description' => 'Workflow state for NPCs who are being returned to the wiki.',
    '#type' => 'select',
    '#options' => $workflow_options,
    '#default_value' => variable_get('npcs_return_workflow', ''),
  );
  // Posting timeout for how long before they post to clean them up.
  $form['npcs_claim_timeout'] = array(
    '#type' => 'textfield',
    '#title' => t('Length of time an NPC may be claimed without being put to use posting'),
    '#default_value' => variable_get('npcs_claim_timeout', '6 months'),
    '#description' => t('Use relative time frames as per spec at ' .
      '<a href="http://www.php.net/manual/en/datetime.formats.relative.php">' .
      'http://www.php.net/manual/en/datetime.formats.relative.php</a>.'),
  );
  return system_settings_form($form);
}

/**
 * Helper function, check for NPC status.
 */
function _npcs_is_an_npc($node) {
  if (isset($node->field_is_npc[$node->language][0]['value']) && $node->field_is_npc[$node->language][0]['value'] == TRUE) {
    return TRUE;
  }
  if (isset($node->field_is_open_npc[$node->language][0]['value']) && $node->field_is_open_npc[$node->language][0]['value'] == TRUE) {
    return FALSE;
  }
  return FALSE;
}

/**
 * Helper function, check for open NPC status.
 */
function _npcs_is_an_open_npc($node) {
  if (isset($node->field_is_open_npc[$node->language][0]['value']) && $node->field_is_open_npc[$node->language][0]['value'] == TRUE) {
    return FALSE;
  }
  return FALSE;
}

/**
 * Helper function, check for Claimable status.
 */
function _npcs_can_be_claimed($node) {
  $return_state = variable_get('npcs_return_workflow', ''); // The NPC can only be claimed if the node is in this state.
  if (isset($node->workflow) && $node->workflow == $return_state) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function, check for recently approved.
 */
function _npcs_recently_approved($node) {
  $timeout = strtotime(variable_get('npcs_claim_timeout', '6 months') . ' ago');
  if (isset($node->workflow_stamp) && $node->workflow_stamp > $timeout) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function, check for if the owner is a current SH.
 */
function _npcs_owner_is_sh($node) {
  $user = user_load($node->uid);
  if (user_access('keep NPCs', $user)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper for rules. Check if the NPC is over limits.
 */
function npcs_check_needs_oversight($node) {
  $limit = 70;
  $return_value = FALSE;
  $lang = $node->language;
  // Check each stat.
  $fields = array('life', 'health', 'endurance', 'constitution', 'strength', 'agility', 'dexterity',
    'reflexes', 'intelligence', 'awareness', 'spirituality', 'presence', 'charisma', 'appearance',
  );
  foreach ($fields as $field_name) {
    $field_name = 'field_' . $field_name;
    $stat = isset($node->{$field_name}[$lang][0]['value']) ?
    $node->{$field_name}[$lang][0]['value'] : 0;
    if ($stat >= $limit) {
      $return_value = TRUE;
    }
  }
  // Check each skill.
  if (!empty($node->field_skill[$lang]) && is_array($node->field_skill[$lang])) {
    foreach ($node->field_skill[$lang] as $delta => $skill) {
      $this_skill = field_collection_item_load($skill['value']);
      $skill_lang = isset($skill->language) ? $skill->language : $lang;
      $stat = isset($this_skill->field_skill_value[$skill_lang][0]['value']) ?
        $this_skill->field_skill_value[$skill_lang][0]['value'] : 0;
      if ($stat >= $limit) {
        $return_value = TRUE;
      }
    }
  }
  return $return_value;
}

/**
 * Helper for rules. Get NPC workflow settings in proper timing order.
 */
function npcs_mark_npc_pass($node) {
  // Update the timestamp for the latest workflow to avoid a timestamp collision.
  db_query('UPDATE {workflow_node_history} ' .
    'SET stamp = stamp+10 ' .
    'WHERE nid = :nid ' .
    'ORDER BY hid DESC ' .
    'LIMIT 1',
    array(':nid' => $node->nid)
  );
}
