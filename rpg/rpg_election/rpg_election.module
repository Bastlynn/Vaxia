<?php
/**
 * @file
 * Code for Elections.
 */
  // @todo - add a api call to proposal to create components for proposals programatically.
  // @todo - put elections under by department limits for programatically.

/**
 * Implements hook_permission().
 */
function rpg_election_permission() {
  return array(
    'can vote on rpg_elections'=> array(
      'title' => t('can vote on rpg_elections'),
      'description' => t('Vote on rpg_elections.'),
    ),
    'administrate rpg_elections'=> array(
      'title' => t('administrate rpg_elections'),
      'description' => t('Administrate rpg_elections.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function rpg_election_menu() {
  $items['admin/rpg/rpg_election'] = array(
    'title' => 'RPG Election settings',
    'description' => 'Elections for administration positions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_rpg_election_admin_settings'),
    'access arguments' => array('administrate rpg_elections'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_rules_event_info().
 */
function rpg_election_rules_event_info() {
  $items = array(
    'open_election' => array(
      'label' => t('Election open'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
      ),
    ),
    'close_election' => array(
      'label' => t('Election close'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'winner_strings' => array(
            'type' => 'list<text>',
            'label' => t('Winner strings'),
        ),
      ),
    ),
    'runoff_election' => array(
      'label' => t('Election runoff'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election runoff'),
        ),
        'winners' => array(
            'type' => 'list<integer>',
            'label' => t('Winners'),
        ),
        'winner_strings' => array(
            'type' => 'list<text>',
            'label' => t('Winner strings'),
        ),
      ),
    ),
    'cancelled_election' => array(
      'label' => t('Election cancelled'),
      'group' => t('Proposal'),
      'variables' => array(
        'node' => array(
            'type' => 'node',
            'label' => t('Election cancelled'),
        ),
      ),
    ),
  );
  return $items;
}

/**
 * Implements hook_node_delete().
 */
function rpg_election_node_delete($node) {
  // Delete an rpg_election associated with a proposal if we delete the node.
  if ($node->type == 'proposal') {
    _rpg_election_delete_election_by_nid($node->nid);
  }
}

/**
 * Implements hook_node_update().
 */
function rpg_election_node_update($node) {
  // Check a proposal for an rpg_election value.
  if ($node->type == 'proposal') {
    _rpg_election_election_check_close($node);
  }
}

/**
 * Implements hook_cron().
 */
function rpg_election_cron() {
  $last_run = variable_get('election_cron', 0);
  $yesterday = strtotime('-1 day');
  if ($last_run < $yesterday) {
    $today = date('m/d/Y');
    $today = strtotime($today . ' 00:00:01'); // We always want to plan to run just after midnight.
    variable_set('election_cron', $today);
    _rpg_election_cron_election();
  }
}

/**
 * Cron handler for rpg_elections.
 */
function _rpg_election_cron_election() {
  $election_day = _rpg_election_check_election_day();
  if ($election_day) {
    // This is an official rpg_election! Time to get things sorted out.
    // First remove current heads from positions, put admin in for anon mailer.
    $role = variable_get('election_role', '');
    db_query('DELETE FROM {users_roles} WHERE rid = :rid',
      array(':uid' => $winner->uid, ':rid' => $role));
    $data = array('uid' => 1, 'rid' => $role);
    drupal_write_record('users_roles', $data);
    // And start the rpg_election.
    _rpg_election_trigger_election();
  }
}

/**
 * Helper function. Check if today is rpg_election day.
 */
function _rpg_election_check_election_day() {
  // Grab the info about the last rpg_election and when / how to run it.
  $last_held = variable_get('election_day', '5/1/2013');
  $rate = variable_get('election_rate', '1 year');
  // Based on the last rpg_election, get the next rpg_election in a standard format.
  $last_election = strtotime($last_held);
  $next_election = date('m/d/Y', strtotime($rate, $last_election));
  // Calculate today, see if it's the same values in a standard format.
  $today = date('m/d/Y', strtotime('now'));
  // Do they match? Mark today in the variables.
  if ($today == $next_election) {
    variable_set('election_day', date('m/d/Y'));
    watchdog('rpg_election', 'Election day.');
    return TRUE;
  }
  watchdog('rpg_election', 'Not election day.');
  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter(). Remove the rpg_election fields from display or access if not eligable.
 */
function rpg_election_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  // If we're qualified, don't hide anything.
  $roles = variable_get('election_run_roles', '');
  foreach ($roles as $role) {
    if (in_array($role, array_keys($form['#user']->roles))) {
      // Do nothing.
      return;
    }
  }
  // Hide anything in the hidden fieldgroup.
  foreach (element_children($form) as $field_name) {
    if (strpos($field_name,'field_staff_') !== FALSE) {
      $form[$field_name]['#access'] = FALSE;
    }
  }
}

/**
 * Menu callback, admin form.
 */
function _rpg_election_admin_settings($form, &$form_state) {

  $form['election_day'] = array(
    '#title' => t('Last rpg_election day'),
    '#description' => t('The last-held rpg_election day for calculating further rpg_elections.'),
    '#type' => 'textfield',
    '#disabled' => TRUE,
    '#default_value' => variable_get('election_day', '5/1/2013'),
    '#value' => variable_get('election_day', '5/1/2013'),
  );
  $positions = _rpg_election_get_positions();
  $available = implode("\n", $positions);
  if (empty($positions)) {
    $available = implode("\n", array('Setting Lead', 'System Lead', 'Social Lead') );
  }
  $form['election_position_details'] = array(
    '#type' => 'fieldset',
    '#title' => t('Election positions'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['election_position_details']['election_positions'] = array(
    '#title' => t('Available positions'),
    '#description' => t('List postitions available on the site, one per row.'),
    '#type' => 'textarea',
    '#default_value' => $available,
  );
  foreach ($positions as $key => $human_name) {
    $form['election_position_details']['details_' . $key] = array(
      '#type' => 'fieldset',
      '#title' => $human_name,
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['election_position_details']['details_' . $key]['election_position_count_' . $key] = array(
      '#type' => 'select',
      '#title' => t('How many slots in this position?'),
      '#options' => range(0,10),
      '#default_value' => variable_get('election_position_count_' . $key, 2),
    );
    $form['election_position_details']['details_' . $key]['election_position_desc_' . $key] = array(
      '#type' => 'textarea',
      '#title' => t('Additional description for the position.'),
      '#default_value' => variable_get('election_position_desc_' . $key, ''),
    );
  }
  $form['election_times'] = array(
    '#title' => t('Election times'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['election_times']['election_rate'] = array(
    '#title' => t('Election rate'),
    '#description' => t('How often to hold rpg_elections. Use timeframe formats strtotime will recognize.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_rate', '1 year'),
  );
  $form['election_times']['election_term_limits'] = array(
    '#title' => t('Term limits'),
    '#description' => t('Use term limits when calculating eligable users for positions.'),
    '#type' => 'checkbox',
    '#default_value' => variable_get('election_term_limits', TRUE),
  );
  $form['election_times']['election_term_limit_limits'] = array(
    '#title' => t('Term limit'),
    '#description' => t('How many consecutive (not lifetime) terms can a user serve in the same position.'),
    '#type' => 'textfield',
    '#default_value' => variable_get('election_term_limit_limits', 2),
  );
  $form['election_roles'] = array(
    '#title' => t('Election roles'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['election_roles']['election_run_roles'] = array(
    '#title' => t('Election run role'),
    '#description' => t('These roles are allowed to run.'),
    '#type' => 'select',
    '#multiple' => TRUE,
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_run_roles', array()),
  );
  $form['election_roles']['election_role'] = array(
    '#title' => t('Elected role'),
    '#description' => t('This role is considered the elected role. Election winners automatically recieve this role.'),
    '#type' => 'select',
    '#options' =>  user_roles(),
    '#default_value' => variable_get('election_role', ''),
  );
  $form['election_setup'] = array(
    '#title' => t('Election setup'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $vid = variable_get('forum_nav_vocabulary', 0);
  $options = array();
  if ($terms = taxonomy_get_tree($vid)) {
    foreach ($terms as $term) {
      $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
    }
  }
  $form['election_setup']['election_default_forum'] = array(
    '#title' => t('Election forum'),
    '#description' => t('The default forum to post the rpg_election proposal in.'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => variable_get('election_default_forum', ''),
  );
  $intro_text = t('Each year we have an rpg_election for key positions on our site. ' .
    'This is so that we can always be sure that the current leadership is connected to ' .
    'and trusted by our players.');
  $form['election_setup']['election_election_intro'] = array(
    '#title' => t('Election intro'),
    '#description' => t('Election introduction text.'),
    '#type' => 'textarea',
    '#default_value' => variable_get('election_election_intro', $intro_text),
  );
  $form['election_counting'] = array(
    '#title' => t('Election counting'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['election_counting']['election_min_numb'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use a minimum number of votes for voting.'),
    '#default_value' => variable_get('election_min_numb', TRUE),
  );
  $form['election_counting']['election_min_numb_val'] = array(
    '#type' => 'textfield',
    '#title' => t('Min vote%'),
    '#description' => t('Minimum number of votes to even be considered for position.'),
    '#default_value' => variable_get('election_min_numb_val', '2'),
  );
  $form['election_counting']['election_min_perc'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use a minimum percentage of votes for voting.'),
    '#default_value' => variable_get('election_min_perc', TRUE),
  );
  $form['election_counting']['election_min_perc_val'] = array(
    '#type' => 'textfield',
    '#title' => t('Min vote%'),
    '#description' => t('Minimum percentage of votes to even be considered for position.'),
    '#default_value' => variable_get('election_min_perc_val', '50'),
  );
  $form['election_counting']['election_runoff'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically run run-offs.'),
    '#default_value' => variable_get('election_runoff', TRUE),
  );
  $form['election_actions'] = array(
    '#title' => t('Election actions'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['election_actions']['election_open_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Hold an election off-cycle'),
    '#submit' => array('_rpg_election_open_submit'),
  );
  $form['election_actions']['election_close_election'] = array(
    '#type' => 'submit',
    '#value' => t('Close open elections'),
    '#submit' => array('_rpg_election_close_submit'),
  );
  $form['election_actions']['election_check_election'] = array(
    '#type' => 'submit',
    '#value' => t('Check open election votes'),
    '#submit' => array('_rpg_election_check_votes'),
  );
  $form['#submit'][] = '_rpg_election_positions_submit';
  return system_settings_form($form);
}

/**
 * Submit callback, close open rpg_elections.
 */
function _rpg_election_close_submit($form, &$form_state) {
  // And get the correct timeframe assuming a start time of 2 weeks ago.
  $proposals = db_query('SELECT n.nid FROM {node} n ' .
    'LEFT JOIN webform w ON n.nid = w.nid ' .
    'WHERE n.type = \'proposal\' ' .
    'AND n.status = 1 ' .
    'AND w.status = 1 ');
  // Trigger event.
  foreach ($proposals as $proposal) {
    $election = _rpg_election_get_election_by_nid($proposal->nid);
    if ($election) {
      if (function_exists('rules_invoke_event')) {
        $node = node_load($proposal->nid);
        // Clear out the disallowed roles option for this proposal
        $disallowed = variable_get('proposal_disallowed_roles', array());
        if (isset($disallowed[ $node->nid ])) {
          unset($disallowed[ $node->nid ]);
        }
        variable_set('proposal_disallowed_roles', $disallowed);
        // Call the rules.
        rules_invoke_event('close_proposal', $node);
      }
    }
  }
}

/**
 * Submit callback, close open rpg_elections.
 */
function _rpg_election_check_votes() {
  // And get the correct timeframe assuming a start time of 2 weeks ago.
  $proposals = db_query('SELECT n.nid FROM {node} n ' .
    'LEFT JOIN webform w ON n.nid = w.nid ' .
    'WHERE n.type = \'proposal\' ' .
    'AND n.status = 1 ' .
    'AND w.status = 1 ');
  foreach ($proposals as $proposal) {
    $node = node_load($proposal->nid);
    if ($node) {
      $results = _rpg_election_get_results($node);
      drupal_set_message('Results:');
      $votes = array();
      foreach ($results as $submission) {
        foreach ($submission as $position => $uids) {
          foreach ($uids as $uid) {
            $votes[$position][$uid] = !empty($votes[$position][$uid])
              ? $votes[$position][$uid] + 1 : 1;
          }
        }
      }
      foreach ($votes as $position => $users) {
        drupal_set_message(t('Votes for position %position.', array('%position' => $position)));
        foreach ($users as $uid => $votes) {
          $user = user_load($uid);
          drupal_set_message(t('@votes votes for @user.', array('@votes' => $votes,'@user' => $user->name)));
        }
      }
      drupal_set_message('Winners:');
      $all_winners = _rpg_election_get_winners($node, $results);
      foreach ($all_winners as $position => $winners) {
        foreach ($winners as $winner) {
          $user = user_load($winner);
          drupal_set_message(t('@user for position @position.',
            array('@user' => $user->name, '@position' => $position)));
        }
      }
    }
  }
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _rpg_election_open_submit($form, &$form_state) {
  // This is an official rpg_election! Time to get things sorted out.
  // First remove current heads from positions, put admin in for anon mailer.
  $elected_role = variable_get('election_role', '');
  // Remove current people from position.
  // This ONLY happens during rpg_election triggers like form or cron.
  // It does NOT happen on runoff rpg_elections.
  db_query('DELETE FROM {users_roles} WHERE rid = :rid', array(':rid' => $elected_role));
  // Set user one as the temporary position holder.
  $data = array('uid' => 1, 'rid' => $elected_role);
  drupal_write_record('users_roles', $data);
  // And start the rpg_election.
  variable_set('election_day', date('m/d/Y'));
  _rpg_election_trigger_election();
}

/**
 * Submit callback, add user fields for each defined position.
 */
function _rpg_election_positions_submit($form, &$form_state) {
  // Grab the old positions.
  // TODO: For now, leave it to the admin to delete the old ones.
  // Grab the new positions from the settings.
  $positions = isset($form_state['values']['election_positions']) ?
    $form_state['values']['election_positions'] : '';
  $positions = explode("\n", $positions);
  $available = array();
  foreach ($positions as $index => $position) {
    $position = trim($position); // Trim.
    if (!empty($position)) {
      $available[] = $position;
    }
  }
  // Make sure to set the variable early so the position fields can use it.
  variable_set('election_positions', implode("\n", $available));
  // And create fields.
  if (!empty($available)) {
    create_election_position_fields();
  }
}

/**
 * Create an rpg_election set with all relevant data.
 * Title is optional, can be set to override default.
 * Postions optional, can be set to override defaults in for example runoffs.
 * Election is the rpg_election object for tracking the cycle - for runoffs.
 */
function _rpg_election_trigger_election($title = '', $positions = array(), $election = array(), $runoff = FALSE) {
  // Make sure we have the right positions in place.
  create_election_position_fields();
  // Create the node.
  $title = !empty($title) ? $title : t('Site Election: @date', array('@date' => date('Y')));
  $node->title = date('m/d/Y') . ' ' . $title;
  $node->type = 'proposal';
  $node->uid = 1;
  $node->language = 'und';
  // Post to the correct forum.
  $tid = variable_get('election_default_forum', '');
  $node->taxonomy_forums[ $node->language ][0]['tid'] = !empty($tid) ? $tid : '';
  node_save($node);
  $node = node_load($node->nid);
  // Check that the node was properly created.
  if (!empty($node)) {
    // Ok, set up the webform elements for this rpg_election.
    _rpg_election_setup_election_proposal($node, $positions, $election);
  }
  // If we have rules, trigger it.
  // We're starting a new rpg_election cycle.
  if (!$runoff && function_exists('rules_invoke_event')) {
    rules_invoke_event('open_election', $node);
  }
}

/**
 * Helper function. Create an rpg_election webform with the right settings.
 */
function _rpg_election_setup_election_proposal($new_election, $positions = array(), $election = array()) {
  // Figure out the positions.
  // If we were passed positions for this rpg_election, use those. (Probably a runoff.)
  if (empty($positions)) {
    // Otherwise load the list from the stored variable.
    $positions = _rpg_election_get_positions();
  }

  // Trim up for possible bad input.
  foreach ($positions as $index => $position) {
    $position = trim($position);
    if (!empty($position)) {
      $positions[$index] = $position;
    }
  }

  // Set the webform body and basic configuration.
  $output = '';
  $output .= '<h3><b>' . t('Election') . '</b></h3>';
  $output .= '<p>' . variable_get('election_election_intro', '') . '</p>';
  $output .= '<p>' . t('Available positions are:') . '</p>';
  $output .= theme('item_list', array('items' => $positions));
  $output .= '</br><p>Please take a moment to review the candidates for this ' .
    'year and select those you feel to be the best choices for the available ' .
    'positions.</p>'.
    '<p>Where more than one winner for a position is allowed, select ' .
    'your set of top choices for each position. The winners will be selected from ' .
    'the combined results of all choices for the postion.</p>'.
    'The order of the votes doesn\'t matter - both candidates you pick for a given ' .
    'department go into the pool of votes evenly. Your A vote doesn\'t get any more ' .
    'weight than your B vote, so select them in any order you choose.</p>';
  $new_election->body[$new_election->language][0]['value'] = $output;
  // Set up the webform defaults if node hasn't yet.
  if (!isset($new_election->webform)) {
    $new_election->webform = webform_node_defaults();
  }
  $new_election->webform['confirmation'] = t('Thank you for participating!');
  $new_election->webform['confirmation_format'] = 'plain_text';
  $new_election->webform['submit_limit'] = 1;
  // Set approving roles for users based on all roles with 'can vote on rpg_elections' permission.
  $election_voting_roles = user_roles(FALSE, 'can vote on rpg_elections');
  $record = db_query('DELETE FROM {webform_roles} WHERE nid = :nid', array(':nid' => $new_election->nid));
  $roles = array();
  foreach ($election_voting_roles as $rid => $role) {
    if ($role) {
      $roles[] = $rid;
    }
  }
  // Set the default users.
  $new_election->webform['roles'] = $roles;
  _proposal_webform_set_users($roles, array(), $new_election->nid);
  // Set the status to ON on new rpg_elections.
  $new_election->webform['status'] = TRUE;
  node_save($new_election);

  // And now we mark this proposal as having been created in our site as an rpg_election object.
  $election_data = array(
    'nid' => $new_election->nid,
    'positions' => $positions,
    'closed' => -1,
    'winners' => array(),
  );
  $election_data = array_merge( (array) $election, $election_data); // Merge any existing rpg_election info.
  if (isset($election_data['eid'])) {
    // It's a runoff rpg_election, new node, but same cycle, same positions.
    unset($election_data['eid']);
  }
  $election_data = _rpg_election_update_election($election_data);

  // And now the fun part: set the components for the form.
  _rpg_election_setup_election_proposal_components($new_election, $positions, $election_data);

  // And set a message to our user.
  drupal_set_message(t('A new rpg_election has been created at !link.',
    array('!link' => l($new_election->title, 'node/' . $new_election->nid))));
}

/**
 * Helper function. Create the components for an rpg_election form.
 */
function _rpg_election_setup_election_proposal_components($new_election, $positions, $election_data) {
  // Include the webform module that allows components to be created.
  module_load_include('inc', 'webform', 'includes/webform.components');
  // Create the webform fields for possible elected.
  $weight = 0;
  $positions_ready = FALSE;
  $alphabet =   array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');
  foreach ($positions as $position) {
    // Get the key to use.
    $field_key_name = _rpg_election_field_key_name($position);
    if ($field_key_name) {
      // Gather the user info.
      $run_roles = variable_get('election_run_roles', array());
      $run_roles = array_values($run_roles);
      $elected_role = variable_get('election_role', '');
      // This filter removes candidates from sligibility as follows:
      // They're in the role to run.
      // They DO NOT currently have a seat.
      // They haven't opted out.
      $candidates = db_query('SELECT DISTINCT u.name, u.uid FROM {users} u ' . 
        'LEFT JOIN {users_roles} ur ON u.uid = ur.uid ' .
        'LEFT JOIN {field_data_field_staff_' . $field_key_name . '} f ON u.uid = f.entity_id ' .
        'WHERE ur.rid IN (:run_roles) ' .
        'AND u.uid NOT IN (SELECT ur2.uid FROM users_roles ur2 WHERE ur2.rid IN (:elected_role) ) ' .
        'AND f.field_staff_' . $field_key_name . '_value = 1 ' .
        'ORDER BY u.name', // Alphabetical order.
        array(':run_roles' => $run_roles, ':elected_role' => $elected_role));

      // Check the user for eligabilty and term limits.
      $eligable_candidates = '';
      $term_limits = variable_get('election_term_limits', TRUE);
      $term_limits_limit = variable_get('election_term_limit_limits', 2);
      foreach ($candidates as $candidate) {
        $eligable = TRUE;
        if ($term_limits) {
          // Check for this position key if the user has the ok or if they need to lay off for a bit.
          $eligable = !_rpg_election_is_at_term_limit( $candidate->uid, $term_limits_limit, $field_key_name);
        }
        // If we're still ok, add em.
        if($eligable) {
          $eligable_candidates .= $candidate->name . '|' . $candidate->name . "\n";
        }
      }

      // Create the component for the position IF we have any eligable candidates.
      if (!empty($eligable_candidates)) {
        // Get and insert the description.
        $desc = variable_get('election_position_desc_' . $field_key_name, '');
        $desc = trim($desc);
        if (!empty($desc)) {
          $component = array();
          $component['nid'] = $new_election->nid;
          $component['pid'] = 0;
          $component['form_key'] = $field_key_name . '_not_position'; // Use the position fieldname as the key.
          $component['name'] = $position;
          $component['type'] = 'markup';
          $component['mandatory'] = 0;
          $component['value'] = $desc;
          $component['extra'] = array(
            'format' => 'filtered_html',
            'private' => 0,
          );
          $component['weight'] = $weight;
          $weight++;
          webform_component_insert($component);
        }
        // Find out if we're doing doubles or not.
        $slots = variable_get('election_position_count_' . $field_key_name, 2);
        // For every slot we have, where we do not already have someone locked in.
        // Then we run the rpg_election for that slot.
        $currently_held = _rpg_election_get_current_holders($field_key_name, $election_data->cycle);
        for ($i = 0; $i < $slots; $i++) {
          if ($i < count($currently_held)) {
            $component = array();
            $component['nid'] = $new_election->nid;
            $component['pid'] = 0;
            $component['form_key'] = $field_key_name . '_' . $alphabet[$i] .
              '_not_position'; // Use the position fieldname as the key.
            $component['name'] = $position . ' ' . strtoupper($alphabet[$i]);
            $component['type'] = 'markup';
            $component['mandatory'] = 0;
            $component['value'] = $position . ' ' . strtoupper($alphabet[$i]) . ': '.
              t('is currently held by ' . $currently_held[$i]->name . '.');
            $component['extra'] = array(
              'format' => 'filtered_html',
              'private' => 0,
            );
            $component['weight'] = $weight;
            $weight++;
            webform_component_insert($component);
          }
          else {
            $component = array();
            $component['nid'] = $new_election->nid;
            $component['pid'] = 0;
            $component['form_key'] = $field_key_name . '_' . $alphabet[$i]; // Use the position fieldname as the key.
            $component['name'] = $position . ' ' . strtoupper($alphabet[$i]);
            $component['type'] = 'select';
            $component['mandatory'] = 0;
            $component['extra'] = array(
              'description' => '',
              'items' => $eligable_candidates,
              'multiple' => '0',
              'aslist' => '1',
            );
            $component['weight'] = $weight;
            $weight++;
            webform_component_insert($component);
            $positions_ready = TRUE;
          }
        }
      }
      else {
        $component = array();
        $component['nid'] = $new_election->nid;
        $component['pid'] = 0;
        $component['form_key'] = $field_key_name . '_not_position'; // Use the position fieldname as the key.
        $component['name'] = $position;
        $component['type'] = 'markup';
        $component['mandatory'] = 0;
        $component['value'] = $position . ' ' . strtoupper($alphabet[$i]) . ': '.
          t('There are no eligable candidates for ' . $position . '.');
        $component['extra'] = array(
          'format' => 'filtered_html',
          'private' => 0,
        );
        $component['weight'] = $weight;
        $weight++;
        webform_component_insert($component);
        watchdog('election', 'This rpg_election has no candidates for ' . $position . '.');
        drupal_set_message(t('This rpg_election has no candidates for ' . $position . '.'));
      }
    } // Done with the if for each position key name.
  } // Done with loop for positions.

  // If we didn't find anyone for any of these positions we really don't
  // have enough people for an rpg_election. This is an EMERGENCY situation
  // that we should mark as such - also we close the rpg_election right now
  // to avoid triggering any future looping until we're ready to elect.
  if (!$positions_ready) {
    // Reload the rpg_election before saving any changes to make sure we don't
    // zap any components that were placed on it since the last load.
    $new_election = node_load($new_election->nid);
    $new_election->title .= ' ' . t('(Cancelled)');
    $new_election->status = 0; // TMP hiden from view.
    $new_election->webform['status'] = FALSE;
    watchdog('election', 'This rpg_election has no candidates for ANY position. ' .
      'It has been automatically closed without runoff.');
    drupal_set_message(t('This rpg_election has no candidates for ANY position. ' .
      'It has been automatically closed without runoff.'), 'error');
    node_save($new_election);
    // And set rule to trigger in case of a cancelled rpg_election.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('cancelled_election', $new_election);
    }
  }
  else {
    // Copy from proposal.module - include the comment field.
    $component = array();
    $component['nid'] = $new_election->nid;
    $component['pid'] = 0;
    $component['form_key'] = 'additional_comments';
    $component['name'] = t('Additional Comments');
    $component['type'] = 'textarea';
    $component['mandatory'] = 0;
    $component['extra'] = array();
    $component['weight'] = 1000;
    webform_component_insert($component);
  }
}

/**
 * Handle when we close an rpg_election. Called on proposal close.
 */
function _rpg_election_election_check_close($node) {
  $election = _rpg_election_get_election_by_nid($node->nid);
  // Check if we are closed. If we aren't an rpg_election this returns nothing.
  if ($election && $election->closed == -1 && $node->webform['status'] == FALSE) {

    // Close the rpg_election.
    $election->closed = strtotime('now');
    $election->winners = array();
    $elected_role = variable_get('election_role', '');
    // And save this rpg_election as done.
    _rpg_election_update_election($election);
    // Read the results into a readable array.
    // These are merged results, to get the top winners from all positions given.
    $results = _rpg_election_get_results($node);
    $all_winners = _rpg_election_get_winners($node, $results); // Return as assoc array.

    // Gather winners and set them up.
    if (!empty($all_winners)) {
      // User one is no longer required to operated as a temporary position.
      db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
        array(':uid' => 1, ':rid' => $elected_role));
      // Now process the winners, marking them for terms etc as needed.
      foreach ($all_winners as $position => $winners) {
        foreach ($winners as $winner) {
          // Add the winner to the heads role.
          db_query('DELETE FROM {users_roles} WHERE uid = :uid AND rid = :rid',
            array(':uid' => $winner, ':rid' => $elected_role));
          $data = array('uid' => $winner, 'rid' => $elected_role);
          drupal_write_record('users_roles', $data);
          // And for each winner, mark that they've been assigned for this cycle to this position.
          $this_winner = _rpg_election_mark_winner(array(
            'uid' => $winner,
            'cycle' => $election->cycle,
            'position' => $position,
          ));
        }
      }
      // Add to the rpg_election information recorded so far.
      $election->winners = $winners;
    }

    // And save this rpg_election as done.
    _rpg_election_update_election($election);
    // If we have rules, trigger it.
    if (function_exists('rules_invoke_event')) {
      rules_invoke_event('close_election', $node, array_keys($winners), $wins);
    }
  }
}

/**
 * Helper function, given an rpg_election node figure out who the winners are.
 */
function _rpg_election_get_winners($node, $results) {
  // Get election information.
  $candidates = array();
  $votes = array();
  $election_data = _rpg_election_get_election_by_nid($node->nid);

  // Loop over each result to start counting for positions.
  foreach ($results as $positions) {
    foreach ($positions as $position => $votes) {
      foreach ($votes as $uid) {
        // Sun up the votes for position for user by submission.
        $candidates[$position][$uid] = (!empty($candidates[$position][$uid]))
          ? $candidates[$position][$uid] + 1 : 1;
      }
    }
  }

  // Are we filtering results by a minimum number of votes?
  if (variable_get('election_min_numb', TRUE)) {
    $min = variable_get('election_min_numb_val', '2');
    if (is_numeric($min) && ($min > 0)) {
      foreach ($candidates as $position => $positions) {
        foreach ($positions as $uid => $votes) {
          if ($votes < $min) {
            unset($candidates[$position][$uid]);
          }
        }
      }
    }
  }

  // Are we filtering results by a minimum percentage of votes?
  if (variable_get('election_min_perc', TRUE)) {
    $min = variable_get('election_min_perc_val', '50');
    if (is_numeric($min) && ($min > 0)) {
      $min = floor(count($results) * ($min / 100));
      foreach ($candidates as $position => $positions) {
        foreach ($positions as $uid => $votes) {
          if ($votes < $min) {
            unset($candidates[$position][$uid]);
          }
        }
      }
    }
  }

  // Put all winners in position by votes given.
  $votes = array();
  foreach ($candidates as $position => $positions) {
    foreach ($positions as $uid => $vote) {
      $votes[$vote][$position][] = $uid;
    }
  }
  asort($votes);

  // Ok, now that we have our list of winners. You can't hold more than
  // one position at a time. So we need to narrow this down even more.
  // Get positions.
  $positions = _rpg_election_get_positions();
  $election = _rpg_election_get_election_by_nid($node->nid);
  foreach ($positions as $position => $name) {
    $slot_count = variable_get('election_position_count_' . $position, 2);
    // In case this is a runoff, clear out slots already held 
    $currently_held = _rpg_election_get_current_holders($position, $election->cycle);
    $positions[$position] = $slot_count - count($currently_held);
  }
  // And organize the positions by slot value. So we can do them in order.
  asort($positions);

  // Now last step is to make some winner recommendations. Loop over results from top down.
  $found = array();
  $users = array();
  // We're going from the clearest set of votes down to plug people where the site wants most.
  foreach ($votes as $count => $user_positions) {
    foreach ($positions as $position => $slot_count) {
      foreach ($user_positions[$position] as $uid) {
        // Check for an open slot. If we have one, use it.
        $used_slots = !empty($winners[$position]) ? count($winners[$position]) : 0;
        if ($used_slots < $slot_count && !in_array($uid, $users)) {
          // At this point we should have our round of picks, put them all in the bin.
          $winners[$position][] = $uid;
        }
      } // End loop for each user.
    } // End loop for positions.
    // At end of the loop, mark each user assigned.
    foreach ($positions as $position => $slot_count) {
      foreach ($user_positions[$position] as $uid) {
        $users[$uid] = $uid;
      }
    }
  } // End loop for votes by top.

  // Then get the winners based on the positions we have.
  // Allow other modules to modify if they want to.
  drupal_alter('election_winners', $winners, $results, $node);
  return $winners;
}

/**
 * Helper function, summarize rpg_election results in a readable array.
 * We're going to return results in the following order:
 * [VOTE-COUNT][POSITION][USER] where position is sorted by slot size. Small to large.
 */
function _rpg_election_get_results($node) {
  // Local cache of looked up users by name.
  $results = array();
  $users = array();
  $multi_slots = variable_get('election_positions_redundant', TRUE);

  // Get submission results and put into a format for review.
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  $submissions = webform_get_submissions($node->nid);
  // No submissions, no returns.
  if (empty($submissions)) {
    return array();
  }

  // And process the submissions for results.
  foreach ($submissions as $sid => $submission) {
    // Track positions for each submission.
    foreach ($submission->data as $cid => $selected) {
      // Process each position for each compontent.
      $component = $node->webform['components'][$cid];
      if ($component['form_key'] != 'additional_comments' && strpos($component['form_key'], '_not_position') === FALSE) {
        // Get the position key name, accounting for merging multi slots together.
        $position = ($multi_slots) ? substr( $component['form_key'], 0, -2) : $component['form_key'];
        // Get the user. NOTE this is the user's name, not uid.
        $voted_for = $selected['value'][0];
        if (!empty($voted_for)) {
          $voted_for = user_load_by_name($voted_for);
          if (!in_array($voted_for->uid, $results[$sid][$position])) {
            $results[$sid][$position][$voted_for->uid] = $voted_for->uid;
          }
        }
      }
    } // End this component.
  } // End this submission.

  return $results;
}

/**
 * Helper function, create position fields on users given an array of position titles.
 */
function create_election_position_fields() {
  // Add the new position.
  $positions = _rpg_election_get_positions();
  foreach ($positions as $field_key_name => $position) {
    $existing_field = field_info_field('field_staff_' . $field_key_name);
    if (empty($existing_field)) {
      // Set up the data arrays.
      $field = array(
        'active' => '1',
        'cardinality' => '1',
        'deleted' => '0',
        'entity_types' => array(),
        'field_name' => 'field_staff_' . $field_key_name,
        'foreign keys' => array(),
        'indexes' => array(
          'value' => array(
            0 => 'value',
          ),
        ),
        'locked' => '0',
        'module' => 'list',
        'settings' => array(
          'allowed_values' => array(
            0 => 'No',
            1 => 'Yes',
          ),
          'allowed_values_function' => '',
        ),
        'translatable' => '0',
        'type' => 'list_boolean',
      );
      $instance = array(
        'bundle' => 'user',
        'default_value' => array(
          0 => array(
            'value' => 1,
          ),
        ),
        'deleted' => '0',
        'description' => t('I would like to be considered eligible for ' . $position . ' positions during rpg_elections.'),
        'display' => array(
          'default' => array(
            'label' => 'inline',
            'settings' => array(),
            'type' => 'list_boolean',
            'weight' => '6',
          ),
        ),
        'entity_type' => 'user',
        'field_name' => 'field_staff_' . $field_key_name,
        'label' => t('Eligible for ' . $position . ''),
        'required' => 0,
        'settings' => array(
          'user_register_form' => 0,
        ),
        'widget' => array(
          'active' => 1,
          'module' => 'options',
          'settings' => array(
            'display_label' => 1,
          ),
          'type' => 'options_onoff',
        ),
      );
      // Create the field.
      field_create_field($field);
      // Create the instance.
      field_create_instance($instance);
      // Update all existing users to have this field automatically turned on.
      db_query('REPLACE INTO {field_data_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      db_query('REPLACE INTO {field_revision_field_staff_' . $field_key_name . '} ' .
        '(entity_type, bundle, deleted, entity_id, revision_id, language, delta, field_staff_' . $field_key_name . '_value) ' .
        'SELECT \'user\', \'user\', 0, u.uid, u.uid, \'und\', 0, 1 FROM {users} u WHERE u.status = 1');
      // Output message.
      drupal_set_message('Created user field instance: ' . $field_key_name);
    }
  }
  // Flush Entity Cache record.
  if (module_exists('entitycache')) {
    cache_clear_all('*', 'cache_entity_node', TRUE);
  }
}

/**
 * Helper function. Return an array of positions on site, assoc (form_key => human name).
 */
function _rpg_election_get_positions() {
  $saved_positions = variable_get('election_positions', '');
  $saved_positions = explode("\n", $saved_positions);
  $positions = array();
  foreach ($saved_positions as $postion) {
    $postion = trim($postion);
    if (!empty($postion)) {
      $key = preg_replace("/[^A-Za-z0-9_ ]/", '', $postion); // Remove all but space, underscore, and alphanumeric.
      $key = trim(str_replace(' ', '_', strtolower($key))); // Lowercase, replace spaces, trim.
      $positions[$key] = trim($postion);
    }
  }
  return $positions;
}

/**
 * Helper function, translate a human name into a key for field names.
 */
function _rpg_election_field_key_name($position) {
  $positions = _rpg_election_get_positions();
  $key = array_keys($positions, trim($position));
  return !empty($key) ? $key[0] : FALSE;
}

/**
 * Helper function, translate a key into a human name for output.
 */
function get_field_human_name($key) {
  $positions = _rpg_election_get_positions();
  return !empty($positions[$key]) ? $positions[$key] : FALSE;
}

/**
 * CRUD function. Set or create rpg_election info for a node.
 */
function _rpg_election_update_election($election) {
  $data = (array) $election;
  if (!isset($data['nid'])) {
    return FALSE; // We must have a nid for this rpg_election data.
  }
  $old_data = _rpg_election_get_election_by_nid($data['nid']);
  if ($old_data) {
    $data = array_merge( (array) $old_data, $data);
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    drupal_write_record('rpg_election_nodes', $data, 'eid');
  }
  else {
    // New rpg_election post. Set the new cycle and open time.
    $cycle = _rpg_election_get_last_cycle();
    $cycle++;
    $data['cycle'] = !empty($data['cycle']) ? $data['cycle'] : $cycle;
    $data['opened'] = strtotime('now');
    $data['closed'] = -1;
    $data['winners'] = array();
    $data['positions'] = serialize($data['positions']);
    $data['winners'] = serialize($data['winners']);
    // Write it.
    drupal_write_record('rpg_election_nodes', $data);
  }
  // Data returned on pointer, but just in case.
  return (object) $data;
}

/** 
 * Helper function, Given an array_keys modify the data for display in rules.
 */
function _rpg_election_rules_prepare_winner_strings($this_array) {
  // Cast to the right data type.
  $this_array = (array) $this_array;
  // Prepare array of strings.
  $ret_array = array();
  foreach ($this_array as $key => $value) {
    $user = user_load($key);
    $position = get_field_human_name($value);
    $ret_array[] = t('@user has been elected to @position.', array('@user' => $user->name, '@position' => $position));
  }
  return $ret_array;
}

/**
 * CRUD function. Get rpg_election info for an rpg_election.
 */
function _rpg_election_get_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {rpg_election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  $data->positions = unserialize($data->positions);
  $data->winners = unserialize($data->winners);
  return $election;
}

/**
 * CRUD function. Get rpg_election info for a node.
 */
function _rpg_election_get_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('SELECT * FROM {rpg_election_nodes} WHERE nid = :nid',
    array(':nid' => $nid))->fetchObject();
  if (empty($election->eid)) {
    return FALSE; // Bail if error.
  }
  if (!empty($election->positions)) {
    $election->positions = unserialize($election->positions);
  }
  if (!empty($election->winners)) {
    $election->winners = unserialize($election->winners);
  }
  return $election;
}

/**
 * CRUD function. Delete rpg_election info for a node.
 */
function _rpg_election_delete_election($eid) {
  if (empty($eid)) {
    return FALSE; // Bail if error.
  }
  $election = db_query('DELETE FROM {rpg_election_nodes} WHERE eid = :eid',
    array(':eid' => $eid))->fetchObject();
}

/**
 * CRUD function. Delete rpg_election info for a node.
 */
function _rpg_election_delete_election_by_nid($nid) {
  if (empty($nid)) {
    return FALSE; // Bail if error.
  }
  db_query('DELETE FROM {rpg_election_nodes} WHERE nid = :nid',
    array(':nid' => $nid));
}

/**
 * DB function. Get the current max cycle.
 */
function _rpg_election_get_last_cycle() {
  $cycle = db_query('SELECT MAX(cycle) FROM {rpg_election_winners}')->fetchField();
  return !empty($cycle) ? $cycle : 1;
}

/**
 * CRUD function. Set or create rpg_election info for a node.
 */
function _rpg_election_mark_winner($winner) {
  $data = (array) $winner;
  if (empty($data['uid']) || empty($data['cycle']) || empty($data['position'])) {
    return FALSE; // We must have data for this rpg_election data.
  }
  // New rpg_election post. Set the new cycle and open time.
  drupal_write_record('rpg_election_winners', $data);
  // Data returned on pointer, but just in case.
  return (object) $data;
}
// NO DELETE FUNCTION. We do not remove records of rpg_elections to avoid messing up cycle count.

/**
 * DB function. Set or create rpg_election info for a node.
 */
function _rpg_election_get_current_winners($position) {
  $current_cycle = _rpg_election_get_last_cycle();
  $winners = db_query('SELECT uid FROM {rpg_election_winners} ' .
    'WHERE position = :position ' .
    'AND cycle = :cycle',
    array(':position' => $position, ':cycle' => $current_cycle));
  $users = array();
  foreach ($winners as $winner) {
    $users[] = user_load($winner->uid);
  }
  return $users;
}

/**
 * DB function. Set or create rpg_election info for a node.
 */
function _rpg_election_get_current_holders($position, $cycle) {
  $winners = db_query('SELECT uid FROM {rpg_election_winners} ' .
    'WHERE position = :position ' .
    'AND cycle = :cycle',
    array(':position' => $position, ':cycle' => $cycle));
  $users = array();
  foreach ($winners as $winner) {
    $users[] = user_load($winner->uid);
  }
  return $users;
}

/**
 * DB function. Figure out if this user is at term limit.
 */
function _rpg_election_is_at_term_limit($uid, $term_limit, $position) {
  $current_cycle = _rpg_election_get_last_cycle();
  $cycle_limit = $current_cycle - $term_limit;
  $times_held = db_query('SELECT COUNT(uid) AS held FROM {rpg_election_winners} ' .
    'WHERE uid = :uid ' . 
    'AND position = :position ' .
    'AND cycle > :cycle',
    array(':uid' => $uid, ':position' => $position, ':cycle' => $cycle_limit))->fetchField();
  $times_held = !empty($times_held) ? $times_held : 0;
  if ($times_held < $term_limit) {
    return FALSE;
  }
  return TRUE;
}